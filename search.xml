<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Valine初始化头像]]></title>
    <url>%2Fmisc%2Fd6b91886-valine_avatar%2F</url>
    <content type="text"><![CDATA[背景 添加了Valine评论插件后，发现评论者的头像是在_config.yml里面设置一种样式。 如果想改头像只能去Gravatar自行注册账号修改头像。（https://valine.js.org/avatar.html） 默认头像如果评论多了的时候，好难看： 目标本地初始化头像，使相同昵称、相同邮箱的评论者，展示相同的头像。且 兼容远程头像（用户自己去Gravatar设置过头像的，展示用户自己的头像） 行动（上述目标，其实是在经过2个小时采坑填坑之后的最终结果）大致说下采坑过程，与解题思路。感谢舍友的大力支持，不然我这前端小白2天都搞不定。/捂脸 先Google，发现个类似问题：Hexo使用Valine评论系统不显示自定义头像的解决方案 让我知道了Valine的头像是有一组值的 ds: [&quot;mp&quot;, &quot;identicon&quot;, &quot;monsterid&quot;, &quot;wavatar&quot;, &quot;robohash&quot;, &quot;retro&quot;, &quot;&quot;],这就让我有了一个大胆的想法：就用这几个官方头像模板初始化。 获取官方最新的Valine.min.js文件开始改造过程就不详细记录了，大致说下踩到的几个坑： 直接随机显示ds数组里的这几个头像，带来的问题：相同昵称（同一个人）头像可能不一样 拿到的是Valine.min.js压缩过的js，美化后（格式化），无法解析。必须直接去压缩文件中修改js代码 换个思路，将ds数组随机的值，与评论者的昵称做匹配。 看了下Valine的源码：https://github.com/xCss/Valine/blob/master/src/index.js 原来这个头像链接的组成是这样的： `&lt;img class=&quot;vimg&quot; src=&quot;${_avatarSetting[&apos;cdn&apos;]+md5(rt.get(&apos;mail&apos;))+_avatarSetting[&apos;params&apos;]}&quot;&gt;`; src=&quot;https://gravatar.loli.net/avatar/d41d8cd98f00b204e9800998ecf8427e?d=mp&amp;v=1.3.9&quot; 【cdn url】 + 【mail的md5（用于查询用户自定义的头像）】 + 【config.yml中配置的默认头像】 + 【version】 那我只需要把第三部分一改：根据nick的md5值，随机一个0-5的数字，返回ds数组中对应的值。 _nick = a(e.get(&quot;nick&quot;)), _res = _nick.match(/(\d)/)[1], _seed = _res ? Math.floor(_res / 2) : &apos;5&apos;, o = m.hide ? &quot;&quot; : &apos;&lt;img class=&quot;vimg&quot; src=&quot;&apos; + (m.cdn + a(e.get(&quot;mail&quot;)) +&quot;?d=&quot;+(m.ds[_seed] || &quot;mp&quot;) + &apos;&amp;v&apos; + m.params.split(&quot;&amp;v&quot;)[1]) + &apos;&quot;&gt;&apos;,大功告成：My Valine.min.js文件 改造后]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM实战]]></title>
    <url>%2Fstudy%2F1f93cae3-jvm_action%2F</url>
    <content type="text"><![CDATA[常用的Jvm启动参数 -Xmx512m：设置JVM最大可用内存为512M。 -Xms512m：设置JVM初始内存为512m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。 -Xmn200m：设置年轻代大小为200M。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8（young占30%左右） -verbose:gc：开启gc日志 -Xloggc:gcc.log：将日志输出到文件xx(默认位置为桌面) -XX:+PrintGCDetails：打印GC详情 -XX:+PrintGCDateStamps：打印GC时间戳 参考：GC性能优化美团 - 从实际案例聊聊Java应用的GC优化 FGC实战以JxlTest为例，通过gc日志，fix FGC问题。参考阿飞的博客-FGC实战 阅读一下GC日志]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机 - 概念]]></title>
    <url>%2Freading%2F6f8dd084-JVM%2F</url>
    <content type="text"><![CDATA[书单列表： 《实战Java虚拟机》 目录： Java虚拟机的基本结构 常用的垃圾回收算法 引用计数法 标记清除法 复制算法 标记压缩法 分代算法 分区算法 垃圾回收器 串行回收器 并行回收器 CMS回收器 G1回收器 Class装载系统 类装载步骤 双亲委托模式 字节码执行 Class文件结构 JIT Java虚拟机的基本结构 Java栈：由栈帧组成，一个函数对应一个栈帧(函数被调用–&gt;入栈)，[栈顶—当前正在运行的函数]，[弹栈–&gt;①函数正常return;②Exception] 方法区： JDK1.6、1.7 ==&gt; 又叫永久区(Perm) JDK1.8 ==&gt; 叫元数据区(Metaspace)，(默认 可以吃掉所有系统可用内存) 常用的垃圾回收算法“垃圾”：内存中，不会再被使用的对象。 1. 引用计数法==&gt;缺点：①无法处理循环引用；②&apos;+&apos;、&apos;-&apos;计数器浪费性能2. 标记清除法 标记：标记从 根节点 开始的所有可达对象 清除：清除所有未被标记的对象 ==&gt;缺点：回收后的空间不是连续的，在给大对象分配堆空间时 效率低。 3. 复制算法(适用于 存活对象少，垃圾对象比较多的新生代)例：将内存(Java堆)平均分为两块A、B，每次清理只需要将A中存活的对象复制到B中，然后清空A。 从而解决了 回收后空间不连续的问题4. 标记压缩清除法(适用于老年代) 标记 从 根节点 开始的所有可达对象 压缩到内存的一端 清除边界外的所有垃圾 5. 分代算法即 新生代用“**改良的复制算法**”，老年代用“**标记压缩清除法**” ![改良的复制算法](https://tb.nsfocus.co/image/6f8dd084-3.png) - 栈上分配：基于逃逸分析技术，将线程私有的*小对象*打散分配到Java栈上。（函数调用结束后，会自行销毁，不需要垃圾回收器介入从而提高了性能） - 逃逸分析：对象的作用域未逃出函数体(-server模式下 默认开启) - TLAB（Thread-local allocation buffer）：线程本地分配缓存(是一个线程专用的内存分配)。（实质：线程专属区间 ⊂ Eden区间） - 在老年代引入**卡表**(比特位集合，每一位表示老年代的4k空间)，（1：有被新生代引用的对象，0：无,,,,,,）以应对新生代的高频率GC，每次只需扫描卡表中为1的空间即可。6. 分区算法将整个堆划分成连续的不同的小区间，每个小区间独立使用，独立回收。 从而能够更好地控制一次GC产生的停顿时间垃圾回收器 回收器 串行/并行 算法 特点 新生代串行回收器 单线程 复制算法 实现简单 逻辑处理高效 老年代串行回收器 单线程 标记压缩清除 (堆空间较大时)停顿时间长 新生代ParNew回收器 多线程 复制算法 性能要看CPU的并发能力 新生代ParallelGC回收器 多线程 复制算法 [MaxGCPauseMillis][GCTimeRatio] 关注吞吐量 老年代ParallelGC回收器 多线程 标记压缩清除 关注吞吐量 1. CMS回收器[关注系统停顿时间]（Concurrent Mark Sweep）并发标记清除 初始标记：【STW】 标记根对象 并发标记：标记所有可达对象 预清理：正式清理前的准备和检查(并发)，尝试控制一次停顿时间 重新标记：【STW】 修正并发标记 并发清理：(并发)回收垃圾对象 并发充值：重新初始化CMS数据结构和数据 2. G1回收器(Garbage First) 新生代GC：回收处理Eden和SurvivorA区。==&gt; 老年代的区域增多 并发标记周期：SATB(Snapshot-At-The-beginning)：在初始标记时为存活对象建立的快照 混合回收 正常的年轻代GC(改良的复制算法) 优先清理回收集中垃圾比例较高的区域 必要时的Full GC（回收时，内存不足的时候） 新生代GC时，survivor区和老年代区无法容纳幸存对象时 并发标记时，老年代被快速填充 混合GC时，发生空间不足 Class装载系统1. 类装载步骤 - 加载：解析类方法区内的数据结构 并创建实例 - 验证：class文件格式、语义检查、字节码验证、符号引用验证… - 准备：为类在Java堆中分配空间，设置初始值 - 解析：将 类、接口、字段、方法的符号引用转为直接引用 - 初始化：编译器自动生成并执行类的初始化方法123456## 2. 双亲委托模式(系统默认使用)![](https://tb.nsfocus.co/image/6f8dd084-7.png)在类加载的时候， if（当前类已经被加载）{ return 当前可用类; } else { 请求其双亲加载器加载此类； if（success）{ return 可用的类； } else{ 自己加载； return 类； } } ``` 字节码执行 本文为原创文章，包含脚本行为，会经常更新知识点以及修正一些错误，因此转载请保留原出处，方便溯源，避免陈旧错误知识的误导，同时有更好的阅读体验。本文地址：http://nibnait.com/6f8dd084-about-Java-Virtual-Machine/]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络发展史]]></title>
    <url>%2Freading%2Fc500696f-computer_networking_history%2F</url>
    <content type="text"><![CDATA[首先分享一段 《互联网 发展 历史》 的8分钟小视频 概念：将一个个独立的计算机连接起来，即组成了计算机网络。再结合这张图，不难看出 计算机的发展史，也就是计算机网络的发展史 计算机网络的基础知识在计算机网络发展的初期，各家计算机厂商都发明了一套自己的计算机通信协议，不同品牌的计算机无法进行通信，于是ISO▼制定了一个国际标准 OSI协议。 OSI七层参考模型▼： 搭建网络的主要设备 设备 别名 作用 网卡 NIC▼/网络适配器/LAN卡 使计算机连网 中继器(Repeater) 集线器(Hub)==多口中继器 在物理层，将减弱的信号放大并发送 网桥(Bridge) 2层交换机/以太网交换机/链路层交换机/交换集线器(具有网桥功能的Hub) 在数据链路层，校验并转发 数据帧 （将损坏的数据直接丢弃）（ 传送门：各种校验-CRC▼） 路由器(Router) 3层交换机 在网络层，通过IP协议根据IP地址对 数据报 进行转发 4~7层交换机 · 负载均衡· 防火墙(网关)· 带宽控制(优先处理一些及时性要求比较高的通信请求：语音通话)· 特殊应用访问加速、广域网加速器…. 网关(Gateway) · 协议的转换(表示层)与数据的转发(4~7层) 应用网关 代理服务器 · 是网关的一种· 可以从传输层到应用层对数据和访问进行各种控制和处理 ##传输方式的分类 1. 面向有连接型与面向无连接型 面向有连接型 TCP 打电话建##立/断开连接的时候、 面向无连接型 UDP、IP 邮局寄包裹(不需要确认收件人的详细地址是否真实存在)、视频/语音通信的过程(没有必要保证每一帧都成功的传送到达目的地)、 2. 电路交换与分组交换 电路交换 主要用于：过去的电话网。 两台主机通信时 是独占整个电路的。同一电路的其他多台计算机只能等待正在通信的计算机收发信息完毕以后 才有机会使用这条电路。 分组交换 主要用于：现代计算机网络 处理过程：发送端计算机将数据分组发送给路由器，路由器收到这些分组数据以后，缓存到自己的缓冲区，然后再转发给目标计算机 限制：根据网络的拥堵情况，数据到达目标地址的时间有长有短。路由器的缓存饱和或溢出时，容易造成数据丢失。 3. 按接收端的数量分类 单播(Unicast) 1v1通信，打电话。 广播(Broadcast)：同一数据链路内的所有主机 电视频道、收音机频道。 多播(Muticast)：与特定组内的计算机通信 电话/视频会议 “1年1班的同学们，请起立！” 任播(Anycast)：解析特定组内的任意一台计算机 DNS根域名解析服务器(负载均衡) “1年1班的哪位同学上来领一下奖状？” “飞机上哪位乘客是医生？” 本文中提到的一些专有名词： ISO：国际标准化组织(International Organization for Standards) OSI：开放式通信系统互联参考模型(Open System Interconnection) NIC：网络接口卡(Network Interface Card) CRC：循环冗余校验(Cyclic Redundancy Check) WAN：广域网(Wide Area Netword) LAN：局域网(Local Area Network) Internet：网际网（WAN√、LAN√） The Internet：互联网]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络 - 进阶]]></title>
    <url>%2Freading%2Fb3dcfa99-computer_networking_advance%2F</url>
    <content type="text"><![CDATA[目录： 网络层 IP多播 IP隧道 IPv6的地址结构 路径MTU发现 ICMP报文消息类型详解 ICMPv6的邻居探索 #1. 网络层 IP多播： 附：既定已知的多播地址.png IP隧道 用处： MobileIP 多播包的转播（使用IP隧道，使路由器用单播的形式发包） IPv4网络中传送IPv6的包 √ IPv6网络中传送IPv4的包 √ 将数据链路的PPP包用IP包转发时 IPv6的地址结构 路径MTU发现 ICMP报文消息类型详解 ICMP目标不可达消息（类型3） 错误代码1（主机不可达）：路由表中没有该主机信息，或该主机(关机)没有连接到网络 错误代码2（协议不可达）(Protocol Unreachable) 错误代码3（端口不可达）(Port Unreachable) 错误代码4（Fragmentation Needed and Don’t Fragment was Set）：用于MTU探索 ICMP重定向消息（类型5） ICMP超时消息（类型11） 当TTL==0时，IP路由器就会给发送端主机返回一个 ICMP超时消息。 应用：tracerouter。 ICMP回送消息（类型0、8） 用于进行通信的主机或路由器之间，判断所发送的数据包是否已经成功到达对端的一种消息。 应用：ping命令。 ICMP路由探索消息（类型9、10） 主要用于发现与自己相连的网络中的路由器。当一台主机发出ICMP路由请求（Router Solicitaion，类型10）时，路由器则返回ICMP路由器通告消息（Router Advertisement，类型9）给主机。 ICMP地址掩码消息（类型17、18） 主要用于主机或路由器想要了解子网掩码的情况。可以向那些目标主机或路由器发送ICMP地址掩码请求消息（ICMP Address Mask Request，类型17），然后通过接收ICMP地址掩码应答消息（ICMP Address Mask Reply，类型18）获取子网掩码的信息。 ICMPv6的邻居探索 附：ICMPv6常用的报文消息类型 本文中提到的一些专有名词： IGMP：Internet Group Management Protocol MLD(Multicast Listener Discovery)：多播监听发现。 MSS：最大段长度 链路本地单播地址：同一链路内唯一的地址。 AS(Autonomous System)：自治系统 本文为原创文章，包含脚本行为，会经常更新知识点以及修正一些错误，因此转载请保留原出处，方便溯源，避免陈旧错误知识的误导，同时有更好的阅读体验。本文地址：http://nibnait.com/b3dcfa99-Computer-Networking-advanced/]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络 - 基础]]></title>
    <url>%2Freading%2F58316970-computer_networking_basis%2F</url>
    <content type="text"><![CDATA[书单列表： 《图解TCP/IP(第5版)》 《计算机网络：自顶向下方法(原书第6版)》 目录： 数据链路层 共享介质型网络 非共享介质型网络 以太网 VLAN PPP协议 网络层 IPv4编址 NAT技术 IPv6与IPv4数据报格式对比 IP报文的分片与重组 IP协议相关技术 ARP RARP ICMP ICMPv6 DHCP 路由选择算法 距离向量算法 - RIP、RIP2 链路状态算法 - OSPF BGP - 路径向量型协议 传输层 UDP - 用户数据报协议 TCP - 传输控制协议 其他传输层协议 应用层 远程登录 – TELNET、SSH 文件传输 – FTP 电子邮件 – MIME、SMTP、POP、IMAP WWW – HTTP 网络管理 – SNMP、MIB、RMON TCP/IP的诞生： 20世纪90年代，ISO展开了OSI这一国际标准协议的标准化进程。然而，OSI协议并没有得到普及，真正被广泛使用的是TCP/IP协议。究其原因，是因为TCP/IP的标准化过程是一个极其注重实用性的一个流程。 TCP/IP与OSI参考模型 数据链路层在LAN内，校验并转发 数据帧(根据MAC地址▼) 共享介质型网络 多个设备共享同一个载波信道进行发送和接收数据帧，半双工通信▼。 争用方式：CSMA/CD▼ 发前先听 边发边听 冲突即停 延时重发（指数退避等待） 令牌传递方式： 提高网络性能的两种方法：令牌释放(不等待接收方的数据到达确认就将令牌发送给下一站)、令牌追加(多个令牌同时循环) 非共享介质型网络 不共享介质。网络中的每个站直连交换机，由交换机负责转发数据帧。由于发送端和接收端并不共享通信介质，所以这种通信方式是全双工的。 以太网交换机(网桥)：转发表自学原理： 学习源地址 转发同网帧 丢弃异网帧 广播未知帧 环路检测技术： 生成树协议(STP▼)：通过检查网络的结构 以某一个网桥为构造树根，并对每个端口配置权重，来指定优先使用哪些端口以及发生问题时该使用哪些端口。 以太网——有线局域网技术历史：共享介质型网络–&gt;非共享介质型网络 以太网帧格式： VLAN(virtual LAN，虚拟局域网) 在链路层交换机(网桥)上，使用软件将一些端口逻辑地划分成的一个个网段。 可以跨越不同子网、不同类型网络(以太网、FDDI▼、ATM▼等)从而简化网络管理，减少设备投资。 交换机根据VLAN ID， 可以过滤多余的包，从而达到控制流量 减少了网络负载 并 提高了网络的安全性。 PPP(Point-to-Point Protocol): 拨号上网时，一个将IP数据报封装到串行链路的方法。 主要功能： - LCP(链路控制协议)：负责建立、(加密拨号登陆)配置和测试数据链路连接 - NCP(网络控制协议)：负责设置IP地址(IPCP)、连接上一层网络层IP协议：尽力而为(面向无连接的) 一些特殊的IP地址： 网络号 主机号 10进制表示 源地址 目的地址 含义 0 0 0.0.0.0 ✔️ ❌ 本网络上的本主机 0 host-id ✔️ ❌ 本网络上的某台host-id任播 全1 全1 255.255.255.255 ❌ ✔️ 本网络上的广播,不能被路由器转发 net-id 全1 ❌ ✔️ 指定net-id上的所有主机广播 127 任何数(但不能都是0或1) 127.×××.×××.×××（默认：127.0.0.1=localhost） ✔️ ✔️ 本地回环测试地址 NAT▼技术：极大的缓解了IPv4地址不够用的囧境 在本地网络中使用私有地址，在连接互联网时转而使用全局IP地址的技术。 潜在问题：①无法从NAT外部向内部服务器建立连接；②转换表的生成与转换操作都会产生一定的开销。 解决地址短缺的最佳途径还是：普及IPv6。 IPv6 附：IPv4与IPv6数据报格式详解.png IP报文的分片与重组 IPv4:在路由器上分片，在接收端主机上重组。 IPv6:在发送端主机上分配，接收端主机重组。最小的MTU==1280字节 通过“路径MTU发现▼”，以确定分片时最大的MTU的大小。 主要利用一个ICMP不可达消息 将数据链路上MTU的值返回给发送机 ARP▼ 发送端主机根据IP地址，广播寻找其对应的MAC地址，（只适用于IPv4，IPv6中则可以用ICMPv6替代ARP发送邻居探索消息）实现链路内的IP通信。 附：ARP包格式.png ARP缓存表 通常发送端和接受端会把自己接收到的 带有IP地址和MAC地址的ARP响应包/ARP请求包中的信息缓存20分钟。以防止ARP包在网络中被大量广播，造成网络拥塞。 tips：虽然IP地址直到到达目标主机时都没有发生变化，但是数据链路的目标地址(MAC地址)却根据每个链路的不同而发生着变化。 MAC地址和IP地址缺一不可 在以太网上发送IP包时，“下次要经过哪个路由器发送数据报”中的“下一个路由器”就是其相应的MAC地址。 而如果没有IP地址，各个主机通信全靠广播MAC地址，那对于网桥来说将是一场灾难。 RARP 将ARP反过来，从MAC地址定位IP地址。用于将打印机服务器等小型嵌入式设备接入到网络时。 辅助IP的ICMP▼ 用于IP通信过程中，确认网络是否正常工作，以及遇到异常时进行问题的诊断。 附：《计算机网络-进阶》–ICMP报文消息类型详解 ICMPv6 附：《计算机网络-进阶》–ICMPv6的邻居探索 DHCP 在使用DHCP之前，需先将DHCP所要分配的IP地址池、相应的子网掩码，默认路由控制信息，DNS服务器地址设置到服务器上。 DHCP中继代理 使用DHCP中继代理之后，对不同网段的IP地址的分配也可以由一个DHCP服务器统一进行管理和维护。 路由选择算法距离向量算法(Distance-Vector) 根据网络中的距离(跳数)和方向两种信息生成路由控制表。 RIP▼ 选择经过路由器个数最少的路径 每隔30秒与其他相邻的路由器交换自己的路由表 直接相连的网络距离为0。距离的最大值为16，防止发生“无限计数”问题。 缺点： 网络的个数越多，每次所要交换的路由控制信息就越大。 在网络比较稳定时，还要定期交换信息，浪费贷款。 由于每个路由器掌握的信息都不同，其正确性很难保证。 无法实现可变长度子网构造的网络路由控制（路由器未交换子网掩码）。 RIP2 与RIP第一版的工作机制基本相同，增加了一些新的特点： 链路状态算法(Link-State) 在了解网络整个链接状态的基础上，所有路由器都持有相同的路由控制表。 OSPF▼ 选择总的代价较小的路径。 允许多条费用相同的路径(而RIP仅一条路径) 对每条链路，对不同的TOS(服务类型)，设置多种费用测度 在大规模网络中，用层次的OSPF 附：OSPF的工作机制.png 层次OSPF BGP▼ - 路径向量型协议 边界网关协议是连接不同组织机构(不同自治系统)的一种协议。主要用于ISP之间的相互连接。 根据所要经过的AS路径信息访问列表▼进行路由控制。 AS路径信息访问列表(AS Path List)：包含转发方向、距离以及途径所有AS的编号。 传输层 网络层的IP协议相当于邮递员，把IP数据包送到指定IP的目标主机上， 传输层的TCP/UDP则负责 根据包裹信息（应用程序、端口号），判断信息的最终接收人（哪一个应用程序）。 UDP——用户数据报协议 不提供复杂的控制机制，利用IP提供面向无连接的通信服务。并且它是将应用程序发来的数据在收到的那一刻，立刻按照原样发送到网上的一种机制。 即使出现网络拥堵，UDP也无法进行流量控制等避免网络拥堵的行为。此外，传输途中即使出现丢包，UDP也不负责重发。甚至当出现包的到达顺序乱掉时也没有纠正的功能。如果需要这些细节控制，那么不得不交由采用UDP的应用程序去处理。UDP有点类似于用户说什么听什么的机制，但是需要用户充分考虑好上层协议类型并制作相应的应用程序。因此，也可以说，UDP按照“制作程序的那些用户的指示行事”。 由于UDP面向无连接，它可以随时发送数据。再加上UDP本身处理既简单又高效，因此经常用于以下几个方面： 包总量少的通信（DNS、SNMP等） 视频、音频等多媒体通信（即时通信） 限定于LAN等特定网络中的应用通信 广播通信（广播、多播） 首部格式： 附：UDP数据报首部“校验和”字段详解.png TCP——传输控制协议目的：通过IP数据报实现可靠性传输 特点： 丢包时的重发控制 对次序乱掉的分包进行顺序控制 面向有连接的协议，只有在确认对端存在时才会发送数据，从而可以控制通信流量的浪费 使用序列号和确认应答号实现顺序控制、窗口控制与重发控制。 使用窗口大小来实现对TCP的流量大小的控制 和 拥塞控制 首部格式： 附：TCP数据报首部格式各字段详解.png TCP连接的建立与终止：(传说中的三次握手与四次挥手) 在数据通信之前，主机A通过TCP首部发送一个SYN包作为建立连接的请求（ACK=0,SYN=1，声明一个起始序号seq=x）等待确认应答 主机B收到A要建立连接的请求，返回一个允许连接的SYNACK报文段（ACK=1,SYN=1，主机B的起始序号seq=y，确认应答号ack=x+1） 为防止“已失效的连接请求报文段▼”突然又传回B，主机A再进行一次确认（ACK=1,SYN=0，主机A的起始序列号seq=x+1，确认应答号ack=y+1） 数据传输结束之后，主机A可以发送一个TCP首部（FIN=1，主机A的起始序列号seq=u），请求断开连接。 主机B收到“A不再发送数据的消息”后，返回一个确认报文（ACK=1,seq=v，ack=u+1）A收到B的确认后，进入等待状态，等待B请求释放连接。 B数据发送完成之后，向A请求断开连接（FIN=1,ACK=1,seq=w，ack=u+1） A收到B的断开请求后，回复一个确认信息，并进入TIME_WAIT状态▼，等待2MSL时间。 虽然三次握手方式管理TCP连接可以更好地避免无连接，但这种协议为DOS攻击▼（更确切的说是SYN洪泛攻击▼）提供了可乘之机。 使用序列号和确认应答号实现顺序控制、窗口控制与重发控制 其他传输层协议 UDP-Lite（Lightweight User Datagram Protocol，轻量级用户数据报协议） SCTP（Stream Control Transmission Protocol，流控制传输协议） DCCP（Datagram Congestion Control Protocol，数据报拥塞控制协议） 附：已经步入实用阶段的几个传输层协议详解.png 应用层。。。写不动了 附：几道常考的计算题.pptx 本文中提到的一些专有名词： MAC地址(Media Access Control Address)：介质访问控制地址。系统在网络上的唯一硬件编号，每个网卡都需要有一个唯一的MAC地址。 CSMA/CD(Carrier Sense Mutiple Access/Collision Detection)：具有碰撞检测的载波侦听多路访问 半双工：只发送或只接受的通信方式。比如：无线电收发器，若两端同时说话，是听不见对方说的话的。 全双工：发送数据的同时也可以接收数据。比如：打电话。 STP：Spanning Tree Protocol SFD：Start Frame Delimiter FDDI(Fiber Distribute Data Interface)：分布式光纤数据接口。 ATM(Asynchronous Transfer Mode)：一种以信元为单位的异步传输模式。 网络收敛：网络拥堵时，路由器或交换机发生丢包的现象。 PPPoE(PPP over Ethernet)：利用PPP的验证功能使各家ISP▼有效地管理终端用户的使用，实现按时计费。 ISP:Internet Service Provider NAT：Network Address Translator Path MTU Discovery：发现路径中存在的所有数据链路中最小的MTU▼ MTU：Maximum Transmission Unit。参见《计算机网络-进阶》–路径MTU发现 ARP(Address Resolution Protocol)：地址解析协议 RARP：Reverse Address Resolution Protocol ICMP：Internet Control Managemet Protocol DHCP：Dynamic Host Configuration Protocol RIP：Routing Information Protocol OSPF：Open Shortest Path First BGP(Border Gateway Protocol)：边界网关协议 已失效的连接请求报文段： DOS攻击：deny of service SYN洪泛攻击:攻击者发送大量的TCP SYN报文段，而有意不进行第三次握手的步骤，直至服务器消耗完为第一次握手连接保留的有限资源。 TIME_WAIT状态： 在TIME_WAIT状态中，如果TCP client端最后一次发送的ACK丢失了，它将重新发送。TIME_WAIT状态中所需要的时间是依赖于实现方法的。典型的值为30秒、1分钟和2分钟。等待之后连接正式关闭，并且所有的资源(包括端口号)都被释放。 2MSL(Maximum Segment Lifetime,最大报文生存时间)：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假想网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的MBP]]></title>
    <url>%2Ftool%2Fbc5d8083-my_mbp%2F</url>
    <content type="text"><![CDATA[必备工具ChromeiTerm2 + Homebrew + zsh Alfred 有道 workflow 剪切板[支持正版，自行购买下载] 万年历直接App Store免费下载 CleanMyMac彻底卸载App[支持正版，自行购买下载] 效率工具ManicoApp切换直接App Store免费下载，建议将IntelliJ IDEA加入静默模式 Spectacle分屏工具[支持正版，自行购买下载] Sublime Text 3download ctrl + ` 获取package control最新安装代码：https://packagecontrol.io/installation cmd+shift+ppackage control: install packagecmd+shift+ppretty json 专业工具Parallels Desktop虚拟机 Java开发环境JDK JDK 1.8：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html JDK 1.7：http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html JDK 1.6：http://www.oracle.com/technetwork/java/javase/downloads/java-archive-downloads-javase6-419409.html JDK 1.5：http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-javase5-419410.html MavenIDEAdownloadlanyus 算法测试Code Templates: 12345678910111213141516#if ($&#123;PACKAGE_NAME&#125; &amp;&amp; $&#123;PACKAGE_NAME&#125; != "")package $&#123;PACKAGE_NAME&#125;;#end#parse("File Header.java")import junit.framework.TestCase;import org.junit.Test;/* */public class $&#123;NAME&#125; extends TestCase &#123; @Test public void testCase() &#123; &#125;&#125; XmindVisual ParadigmDiffMerge文本比较工具download Charles装X工具Aerial桌面屏保 iStat Menus[支持正版，自行购买下载] uBarwin风格的任务栏[支持正版，自行购买下载] Commander One文件管理[支持正版，自行购买下载]]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2Ftool%2F34fef994-linux_command%2F</url>
    <content type="text"><![CDATA[查看大文件进入根目录，查看那个目录的利用率(used)达到了100% df -lh #查看磁盘空间占用情况（每天一个linux命令（33）：df 命令） 进入log目录， du -h #显示当前目录下的文件的磁盘空间使用情况相当于 ls -aslh（每天一个linux命令（34）：du 命令） grephttps://www.cnblogs.com/peida/archive/2012/12/17/2821195.html less每天一个linux命令（13）：less 命令]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git小技巧]]></title>
    <url>%2Ftool%2F7e6679d9-git_skills%2F</url>
    <content type="text"><![CDATA[批量删除分支git branch | grep &apos;hotfix&apos; | xargs git branch -D git rebase统计代码行数git log --author=&quot;username&quot; --pretty=tformat: --numstat | awk &apos;{ add += $1; subs += $2; loc += $1 - $2 } END { printf &quot;added lines: %s, removed lines: %s, total lines: %s\n&quot;, add, subs, loc }&apos; - git log --author=&quot;nibnait&quot; --pretty=tformat: --numstat | awk &apos;{ add += $1; subs += $2; loc += $1 - $2 } END { printf &quot;added lines: %s, removed lines: %s, total lines: %s\n&quot;, add, subs, loc }&apos;]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac小技巧]]></title>
    <url>%2Ftool%2F378ad01b-mac_skills%2F</url>
    <content type="text"><![CDATA[解压.rar、.7z文件 unrar x 1.rar7z e 1.7z before: brew install unrar brew search 7zbrew install p7zip 坑Updating Homebrew... 法1： 替换brew.git:cd “$(brew –repo)”git remote set-url origin https://mirrors.ustc.edu.cn/brew.git 替换homebrew-core.git:cd “$(brew –repo)/Library/Taps/homebrew/homebrew-core”git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git 法2: 重置brew.git:cd “$(brew –repo)”git remote set-url origin https://github.com/Homebrew/brew.git 重置homebrew-core.git:cd “$(brew –repo)/Library/Taps/homebrew/homebrew-core”git remote set-url origin https://github.com/Homebrew/homebrew-core.git]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo启用cdn加速]]></title>
    <url>%2F83f2d349-cdn%2F</url>
    <content type="text"><![CDATA[参考：https://shup.cn/2017/11/21/cdn.html 分析：哪些因素会影响加载速度？js文件js文件就是JavaScript脚本文件，用来实现各种酷炫的动态效果。一般是加载在html页面的部分，所以页面加载速度首先要考虑这一块。Hexo的js文件大致包含以下3类： 公共js公共js是通用型，比如实现图片放大效果的Fancybox，或者实现图片慢加载的LazyLoad等等。这些js已经开发好，直接在html里引用(存放在镜像网站上，如BootCDN)js文件链接即可实现效果。 定制页面效果js即NexT主题中定制的某些特效，例如实现页面响应式效果的Bootstrap，或者增强移动端滚动及动画效果的Motion等等。这些js理论上也是公共js，只不过NexT主题作者修改了代码，以适用于NexT主题。这些js文件存放在本地Hexo目录hexo\themes\next\source\js\src下。 第三方插件js这个不用多说了吧，Hexo默认安装了不少实用的第三方插件，比如，可直接在网页中显示数学公式的MathJax，优化SEO的Baidu-push等等。这些插件可在主题配置文件_config.yml中进行配置。相关js文件有些存放在hexo\themes\next\layout_third-party中，有些则通过外部引用形式加载。图片(音、视频)如果博客文章很多，绝大部分的带宽都会消耗在这部分静态数据上。这个不多说了。 解决：逐个优化公共js加速修改_config.yml中 vendors 的配置全部映射到BootCDN上去 第三方js文件、图片(音、视频)加速我用的七牛云，每月 10 G的标准存储 CDN 回源流量免费额度https://blog.qiniu.com/archives/8874)。]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo启用https加密连接]]></title>
    <url>%2Fa2a28780-https%2F</url>
    <content type="text"><![CDATA[CloudFlare 提供免费的SSL证书和cdn加速服务。目前还在研究中。]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World Mac版]]></title>
    <url>%2Fhello-world%2F</url>
    <content type="text"><![CDATA[安装nodehttps://nodejs.org/en/ 测试 npm -vnode -v 安装hexo sudo npm install hexo –savesudo npm install -g hexo 测试 hexo -v 初始化hexo mkdir hexocd hexohexo init Install dependencies时，出现了一些mkdir权限的问题，日志提示要手动npm install sudo npm install hexo generate 在Hexo 3.0 后server被单独出来了，需要安装server sudo npm install hexo-server -savesudo npm install hexo-deployer-git –save 预览 hexo s 发布 hexo d -g 安装调试主题参考： https://www.jianshu.com/p/9f0e90cc32c2 http://eternalzttz.com/hexo-next.html修改网站图标 favicon修改菜单栏 hexo new page “tags” 去/themes/next/source/tags的index.md文件中，添加type: “tags”打开github_banner添加RSS&gt; npm install hexo-generator-feed --save 在/_config.yml 中添加 plugins: hexo-generate-feed 修改底部标签样式修改Blog\themes\next\layout_macro\post.swig中文件，command+f搜索rel=&quot;tag&quot;&gt;#，将#替换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;。输入以下命令，查看效果： 侧边栏社交小图标设置social: 网站底部加上访问量 在themes/next/layout/_partials/footer.swig第一行加上 &lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; busuanzi_count: enable: true统计博客全站字数 npm install hexo-wordcount –save /themes/next/layout/_partials/footer.swig &lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;博客全站共{{ totalcount(site) }}字&lt;/span&gt; &lt;/div&gt; symbols_count_time: item_text_total: true统计文章字数、阅读时间&lt;span class=&quot;post-count&quot;&gt; &amp;nbsp | &amp;nbsp &lt;i class=&quot;fa fa-print&quot;&gt;&lt;/i&gt; 字数统计：{{ wordcount(post.content) }}&lt;/span&gt; &lt;span class=&quot;post-count&quot;&gt; &amp;nbsp | &amp;nbsp &lt;i class=&quot;fa fa-clock&quot;&gt;&lt;/i&gt; 阅读时长≈{{ min2read(post.content, {cn: 300, en: 160}) }}分钟&lt;/span&gt; # Post wordcount display settings # Dependencies: https://github.com/willin/hexo-wordcount post_wordcount: item_text: true wordcount: true # 字数统计 min2read: true # 预计阅读时长 totalcount: true # 总字数统计 separated_meta: true添加网页顶部进度加载条编辑主题配置文件，command+F搜索pace，将其值改为ture就可以了，选择一款你喜欢的样式。Installation 参考：https://github.com/theme-next/theme-next-pace pace: true浏览页面的时候显示当前浏览进度# Scroll percent label in b2t button. scrollpercent: true添加基于Valine的评论模块valine: enable: true # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version. appid: RN3HHH17DaSH4MgBW1bwRIHj-gzGzoHsz appkey: tDXty7nXldylBkVzfPLPnuGU notify: true # mail notifier, See: https://github.com/xCss/Valine/wiki verify: true # Verification code placeholder: ヾﾉ≧∀≦)o来啊，快活啊! # comment box placeholder avatar: mp # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size language: zh-cn # language, available values: en, zh-cn visitor: false # leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors&apos; for counter compatibility. Article reading statistic https://valine.js.org/visitor.html comment_count: true # if false, comment count will only be displayed in post page, not in home page vendors: valine: https://tb.nsfocus.co/js/Valine.min_6.js添加基于Mob ShareSDK的分享功能参考：https://hadronw.com/2018/05-28/hexo-addshares/ 博文置顶 修改hexo-generator-index插件，把node_modules/hexo-generator-index/lib/generator.js中代码替换为： &apos;use strict&apos;; var pagination = require(&apos;hexo-pagination&apos;); module.exports = function(locals){ var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) { if(a.top &amp;&amp; b.top) { // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 } else if(a.top &amp;&amp; !b.top) { // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; } else if(!a.top &amp;&amp; b.top) { return 1; } else return b.date - a.date; // 都没定义按照文章日期降序排 }); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, { perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: { __index: true } }); }; 文章添加Top值，值越大，越靠前： --- title: Hexo-NexT主题配置 date: 2018-01-20 20:41:08 categories: Hexo tags: - Hexo - NexT top: 100 --- 添加侧栏推荐阅读编辑主题配置文件，如下配置即可： # Blog rolls links_icon: link links_title: 推荐阅读 #links_layout: block links_layout: inline links: Swift 4: https://developer.apple.com/swift/ Objective-C: https://developer.apple.com/documentation/objectivec修改字体大小编辑Blog/themes/next/source/css/_variables/base.styl，command+F搜索$font-size-base，修改为你想要的大小： // Font size $font-size-base = 16px在文章底部增加版权信息 在目录Blog/themes/next/layout/_macro/，添加文件 my-copyright.swig，内容如下：my-copyright.swig 在目录Blog/themes/next/source/css/_common/components/post/下添加文件my-post-copyright.styl，添加以下代码：my-post-copyright.styl 修改Blog/themes/next/layout/_macro/post.swig，在如图位置添加以下代码： &lt;div&gt; {% if not is_index %} {% include 'my-copyright.swig' %} {% endif %} &lt;/div&gt; 在Blog/themes/next/source/css/_common/components/post/post.styl文件最后加入下面的代码： @import &quot;my-post-copyright&quot; 在Markdown文章中加入 copyright : ture --- title: Hexo-NexT主题配置 date: 2018-01-20 20:41:08 categories: Hexo tags: - Hexo - NexT top: 100 copyright: ture --- 配置根目录下的_config.yml文件，配置为： # URL ## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos; url: http://tianbin.org root: / permalink: :year/:month/:day/:title/ permalink_defaults:Hexo博客添加站内搜索 NexT主题支持集成 Swiftype、 微搜索、Local Search 和 Algolia。下面介绍Local Search的安装吧。 安装 hexo-generator-search npm install hexo-generator-search –save 安装 hexo-generator-searchdb npm install hexo-generator-searchdb –save 打开local_search local_search: enable: ture为文章中的代码块增加一键复制功能copy_button: enable: true404公益页面 在source下新建404.md --- comments: false --- &lt;script type=&quot;text/javascript&quot; src=&quot;//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js&quot; homepagename=&apos;返回主页&apos; homepageurl=&quot;/&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; 修改theme/_config.yml menu: commonweal: /404/ || heartbeat移动端启用侧边栏目录# Enable sidebar on narrow view (only for Muse | Mist). onmobile: true 自动备份Hexo博客源文件参考：备份Hexo博客源文件 安装shelljs模块 npm install –save shelljs 编写脚本文件，内容如下：auto_backup_script.js]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
