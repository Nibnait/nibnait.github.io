<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TBlogs</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tianbin.org/"/>
  <updated>2019-07-15T18:28:24.655Z</updated>
  <id>https://tianbin.org/</id>
  
  <author>
    <name>NibNait&amp;nbsp&amp;nbsp</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IntelliJ IDEA 实用插件推荐</title>
    <link href="https://tianbin.org/tool/idea_plugin/"/>
    <id>https://tianbin.org/tool/idea_plugin/</id>
    <published>2019-07-14T07:52:35.000Z</published>
    <updated>2019-07-15T18:28:24.655Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：<a href="https://mp.weixin.qq.com/s/LtEcayFGcc993gHfS6klAQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/LtEcayFGcc993gHfS6klAQ</a></p><a id="more"></a><h1 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h1><p>在编译期自动生成get、set 等方法</p><h1 id="GenerateAllSetter"><a href="#GenerateAllSetter" class="headerlink" title="GenerateAllSetter"></a>GenerateAllSetter</h1><p>一键调用一个对象的所有的set方法</p><h1 id="Alibaba-Java-Coding-Guidelines"><a href="#Alibaba-Java-Coding-Guidelines" class="headerlink" title="Alibaba Java Coding Guidelines"></a>Alibaba Java Coding Guidelines</h1><p>阿里巴巴出品的java代码规范插件，可以扫描整个项目找到不规范的地方 并且大部分可以自动修复 。虽说检测功能没有findbugs强大，但是可以自动修复，阿里巴巴Java编码指南插件支持。</p><h1 id="VisualVM-Launcher"><a href="#VisualVM-Launcher" class="headerlink" title="VisualVM Launcher"></a>VisualVM Launcher</h1><p>运行java程序的时候启动visualvm，方便查看jvm的情况 比如堆内存大小的分配<br>某个对象占用了多大的内存，jvm调优必备工具</p><p>客户端：<a href="https://visualvm.github.io/download.html" target="_blank" rel="noopener">https://visualvm.github.io/download.html</a><br>安装完客服端，需在Preferences -&gt; Other Settings -&gt; VisualVM Launcher 绑定VisualVM excutable，（客户端start文件）</p><h1 id="Maven-Helper"><a href="#Maven-Helper" class="headerlink" title="Maven Helper"></a>Maven Helper</h1><p>一键查看maven依赖，查看冲突的依赖，一键进行exclude依赖</p><h1 id="FindBugs-IDEA"><a href="#FindBugs-IDEA" class="headerlink" title="FindBugs-IDEA"></a>FindBugs-IDEA</h1><p>用静态分析方法标识出Java程序中上百种潜在的不同类型的错误。</p><p><strong>附:FindBugs的Bug种类说明</strong></p><h2 id="Bad-practice-坏的实践"><a href="#Bad-practice-坏的实践" class="headerlink" title="Bad practice 坏的实践"></a>Bad practice 坏的实践</h2><p>一些不好的实践，下面列举几个：</p><ul><li>HE：类定义了equals()，却没有hashCode()；或类定义了equals()，却使用Object.hashCode()；或类定义了hashCode()，却没有equals()；或类定义了hashCode()，却使用Object.equals()；类继承了equals()，却使用Object.hashCode()。</li><li>SQL：Statement 的execute方法调用了非常量的字符串；或Prepared Statement是由一个非常量的字符串产生。</li><li>DE：方法终止或不处理异常，一般情况下，异常应该被处理或报告，或被方法抛出。<br>Malicious code vulnerability 可能受到的恶意攻击</li></ul><p>如果代码公开，可能受到恶意攻击的代码，下面列举几个：</p><ul><li><p>FI：一个类的finalize()应该是protected，而不是public的。</p></li><li><p>MS：属性是可变的数组；属性是可变的Hashtable；属性应该是package protected的。</p></li></ul><p>类名小写问题</p><ul><li>Class names should start with an upper case letter</li></ul><h2 id="Correctness-一般的正确性问题"><a href="#Correctness-一般的正确性问题" class="headerlink" title="Correctness 一般的正确性问题"></a>Correctness 一般的正确性问题</h2><p>可能导致错误的代码，下面列举几个：</p><ul><li><p>NP：空指针被引用；在方法的异常路径里，空指针被引用；方法没有检查参数是否null；null值产生并被引用；null值产生并在方法的异常路径被引用；传给方法一个声明为@NonNull的null参数；方法的返回值声明为@NonNull实际是null。</p></li><li><p>Nm：类定义了hashcode()方法，但实际上并未覆盖父类Object的hashCode()；类定义了tostring()方法，但实际上并未覆盖父类Object的toString()；很明显的方法和构造器混淆；方法名容易混淆。</p></li><li><p>SQL：方法尝试访问一个Prepared Statement的0索引；方法尝试访问一个ResultSet的0索引。</p></li><li><p>UwF：所有的write都把属性置成null，这样所有的读取都是null，这样这个属性是否有必要存在；或属性从没有被write。</p></li></ul><h2 id="Dodgy-危险的"><a href="#Dodgy-危险的" class="headerlink" title="Dodgy 危险的"></a>Dodgy 危险的</h2><p>具有潜在危险的代码，可能运行期产生错误，下面列举几个：</p><ul><li><p>CI：类声明为final但声明了protected的属性。</p></li><li><p>DLS：对一个本地变量赋值，但却没有读取该本地变量；本地变量赋值成null，却没有读取该本地变量。</p></li><li><p>ICAST：整型数字相乘结果转化为长整型数字，应该将整型先转化为长整型数字再相乘。</p></li><li><p>INT：没必要的整型数字比较，如X &lt;= Integer.MAX_VALUE。</p></li><li><p>NP：对readline()的直接引用，而没有判断是否null；对方法调用的直接引用，而方法可能返回null。</p></li><li><p>REC：直接捕获Exception，而实际上可能是RuntimeException。</p></li><li><p>ST：从实例方法里直接修改类变量，即static属性。</p></li></ul><h2 id="Performance-性能问题"><a href="#Performance-性能问题" class="headerlink" title="Performance 性能问题"></a>Performance 性能问题</h2><p>可能导致性能不佳的代码，下面列举几个：</p><ul><li><p>DM：方法调用了低效的Boolean的构造器，而应该用Boolean.valueOf(…)；用类似Integer.toString(1) 代替new Integer(1).toString()；方法调用了低效的float的构造器，应该用静态的valueOf方法。</p></li><li><p>SIC：如果一个内部类想在更广泛的地方被引用，它应该声明为static。</p></li><li><p>SS：如果一个实例属性不被读取，考虑声明为static。</p></li><li><p>UrF：如果一个属性从没有被read，考虑从类中去掉。</p></li><li><p>UuF：如果一个属性从没有被使用，考虑从类中去掉。</p></li></ul><h2 id="Multithreaded-correctness-多线程的正确性"><a href="#Multithreaded-correctness-多线程的正确性" class="headerlink" title="Multithreaded correctness 多线程的正确性"></a>Multithreaded correctness 多线程的正确性</h2><p>多线程编程时可能导致错误的代码，下面列举几个：</p><ul><li><p>ESync：空的同步块，很难被正确使用。</p></li><li><p>MWN：错误使用notify()，可能导致IllegalMonitorStateException异常；或错误的使用wait()。</p></li><li><p>No：使用notify()而不是notifyAll()，只是唤醒一个线程而不是所有等待的线程。</p></li><li><p>SC：构造器调用了Thread.start()，当该类被继承可能会导致错误。</p></li></ul><h2 id="Internationalization-国际化"><a href="#Internationalization-国际化" class="headerlink" title="Internationalization 国际化"></a>Internationalization 国际化</h2><p>当对字符串使用upper或lowercase方法，如果是国际的字符串，可能会不恰当的转换。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考资料：&lt;a href=&quot;https://mp.weixin.qq.com/s/LtEcayFGcc993gHfS6klAQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/LtEcayFGcc993gHfS6klAQ&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="https://tianbin.org/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Mac" scheme="https://tianbin.org/tags/Mac/"/>
    
      <category term="IDEA" scheme="https://tianbin.org/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>Redis 过期key删除策略和内存淘汰策略</title>
    <link href="https://tianbin.org/reading/redis_memory/"/>
    <id>https://tianbin.org/reading/redis_memory/</id>
    <published>2019-07-13T01:28:53.000Z</published>
    <updated>2019-07-15T18:10:28.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h1><p>当Redis中缓存的key过期了，Redis如何处理？<br><a id="more"></a></p><h2 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h2><p>在客户端访问 key 的时候，如果这个 key 设置了过期时间，redis 则对 key 的过期时间进行检查，如果过期了就立即删除。<br>memcached只是用了惰性删除，而Redis同时使用了惰性删除与定期删除</p><h2 id="定期扫描删除"><a href="#定期扫描删除" class="headerlink" title="定期扫描删除"></a>定期扫描删除</h2><p>redis 会将每个设置了过期时间的 key 放入到一个独立的字典中，然后会<strong>定时遍历</strong>这个字典来删除到期的 key。<br>这个定时任务由 src/expire.c 的 activeExpireCycle(ACTIVE_EXPIRE_CYCLE_SLOW) 函数来完成，它的大致步骤是：</p><ol><li>每次从过期字典中随机选取20个key。</li><li>删除这20个key中过期的key。</li><li>如果这20个key中过期key的比例超过了 25%，则重复步骤1。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">src/server.h 中定义的每次获取 key 的数量和比例。</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP 20 <span class="comment">/* Loopkups per loop. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC 25 <span class="comment">/* CPU max % for keys collection */</span></span></span><br></pre></td></tr></table></figure><p>为了防止这个过期扫描出现循环过度，此算法加了一个timelimit变量，函数每次默认最多执行25ms  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认情况下，timelimit=25000(纳秒)</span></span><br><span class="line">timelimit = <span class="number">1000000</span>*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/server.hz/<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((iteration &amp; <span class="number">0xf</span>) == <span class="number">0</span>) &#123; <span class="comment">/* check once every 16 iterations. */</span></span><br><span class="line">  <span class="comment">//删除过期key，每迭代16次，检查一次timelimit</span></span><br><span class="line">  elapsed = ustime()-start;<span class="comment">//ustime()精确到纳秒</span></span><br><span class="line">  <span class="keyword">if</span> (elapsed &gt; timelimit) &#123;</span><br><span class="line">    timelimit_exit = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使加了timelimit，默认每100ms执行一次activeExpireCycle。如果同一时间有大量key过期，在默认情况下 Redis 也会有至少 1 / 4 的时间被阻塞来执行这个activeExpireCycle()方法。为防止出现这种情况，可以在设置过期时间时 后面再个随机值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在目标过期时间上增加一天的随机时间</span></span><br><span class="line">redis.expire_at(key, random.randint(<span class="number">24</span>*<span class="number">3600</span>) + expire_ts)</span><br></pre></td></tr></table></figure><h2 id="从库的过期策略"><a href="#从库的过期策略" class="headerlink" title="从库的过期策略"></a>从库的过期策略</h2><p>从库不会进行过期扫描，从库对过期的处理是被动的。主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库，从库通过执行这条 del 指令来删除过期的 key。<br>因为指令同步是异步进行的，所以主库过期的 key 的 del 指令没有及时同步到从库的话，会出现主从数据的不一致，主库没有的数据在从库里还存在，比如在集群环境中分布式锁的算法漏洞就是因为这个同步延迟产生的。</p><h2 id="单线程的-Redis，如何知道要运行定时任务？"><a href="#单线程的-Redis，如何知道要运行定时任务？" class="headerlink" title="单线程的 Redis，如何知道要运行定时任务？"></a>单线程的 Redis，如何知道要运行定时任务？</h2><p>这个定期扫描删除任务在由 server.c/serverCron() 方法调用，Redis 将 serverCron 方法称作“timer interrupt”（循环时间事件），它每秒的执行次数可以通过redis.conf <code>hz</code>选项（默认是10）来配置。<br>serverCron() 除了定期扫描删除过期key，主要还执行：</p><ul><li>更新服务器的各类统计信息，比如时间（server.lruclock）、内存占用、数据库占用情况等。</li><li>关闭和清理连接失效的客户端。</li><li>尝试进行 AOF 或 RDB 持久化操作。</li><li>如果服务器是主节点的话，对附属节点进行定期同步。</li><li>如果处于集群模式的话，对集群进行定期同步和连接测试。</li></ul><h1 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h1><p>当Redis已用内存超过maxmemory限定时，怎么处理需要新写入且需要申请额外空间的数据？根据redis.conf <code>maxmemory-policy</code> 选项来做对应的清理：</p><ul><li>volatile-lru: 从设置了过期时间的key中，删除最久未使用的key</li><li>allkeys-lru: 从所有key中，删除最近最少使用的key</li><li>volatile-lfu: 从设置了过期时间的key中，删除使用频率最少的key</li><li>allkeys-lfu: 从所有key中，删除使用频率最少的key</li><li>volatile-random: 从设置了过期时间的key中，随机删除</li><li>allkeys-random: 从所有key中，随机删除</li><li>volatile-ttl: 从设置了过期时间的key中，删除马上要过期的key</li><li>noeviction: （Redis的默认淘汰策略）不删除，在写操作时直接报错</li></ul><p>当mem_used达到maxmemory时，所有的写请求都会调用 src/evict.c 的 freeMemoryIfNeeded(void) 方法，执行对应的策略尝试释放一些内存。</p><h2 id="近似的-LRU-算法"><a href="#近似的-LRU-算法" class="headerlink" title="近似的 LRU 算法"></a>近似的 LRU 算法</h2><p>Redis 中的LRU并不是真正的LRU（Least Recently Used），为了避免LRU算法中hash表的内存消耗，Redis 给每个key都增加了一个额外的小字段（lru）：一个24bit长度的，记录着最后一次被访问的时间戳”。</p><p>在执行 Redis LRU 算法时，从待删除的key空间中随机采样<code>maxmemory-samples</code>（默认是5）个key，淘汰最久未访问过的那个key（redis作者测试的结果是当maxmemory-samples = 10时，已经非常接近全量LRU的精准度了）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_BITS 24</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_CLOCK_MAX ((1<span class="meta-string">&lt;&lt;LRU_BITS)-1) /* Max value of obj-&gt;lru */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_CLOCK_RESOLUTION 1000 <span class="comment">/* LRU clock resolution in ms */</span></span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong>LRU 时间戳的默认精度是 1000ms，24bit 可以表示的最长时间大约是194天。</p><ul><li>如果一个 key 超过194天没有被访问，在计算空闲时间的时候，就会少算194天，造成一定的误差。</li><li>为了避免 fork 子进程后额外的内存消耗，当进行 bgsave 或 aof rewrite 时，lru访问时间是不更新的。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 如果对象本身存的lru访问时间 比系统的当前lru clock还要大</span></span><br><span class="line"><span class="comment"> * 那么在计算当前对象的空闲时间的时候，就不能简单的lruclock - o-&gt;lru相减了，需要额外计算*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">estimateObjectIdleTime</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> lruclock = LRU_CLOCK();</span><br><span class="line">    <span class="keyword">if</span> (lruclock &gt;= o-&gt;lru) &#123;</span><br><span class="line">        <span class="keyword">return</span> (lruclock - o-&gt;lru) * LRU_CLOCK_RESOLUTION;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (lruclock + (LRU_CLOCK_MAX - o-&gt;lru)) *</span><br><span class="line">                    LRU_CLOCK_RESOLUTION;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 如果当前 lru clock 的分辨率低于系统刷新频率，则使用系统的时间戳(server.lruclock)</span></span><br><span class="line"><span class="comment"> * 否则调用系统的mstime()函数重新计算*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">LRU_CLOCK</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lruclock;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1000</span>/server.hz &lt;= LRU_CLOCK_RESOLUTION) &#123;</span><br><span class="line">        atomicGet(server.lruclock,lruclock);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lruclock = getLRUClock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lruclock;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 当计算出的当前clock超出LRU_CLOCK_MAX时，就会再次从0开始数</span></span><br><span class="line"><span class="comment"> * server.lruclock也是通过此方法来获取的当前时间*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getLRUClock</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (mstime()/LRU_CLOCK_RESOLUTION) &amp; LRU_CLOCK_MAX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Redis 3.0 之后，又增加了一个<code>eviction pool</code>的结构，eviction pool是一个数组，保存了之前随机选取的key及它们的idle时间，数组里面的key按idle时间升序排序，当内存满了需要淘汰数据时，会调用<code>dictGetSomeKeys</code>选取指定的数目的key，然后更新到eviction pool里面，如果新选取的key的idle时间比eviction pool里面idle时间最小的key还要小，那么就不会把它插入到eviction pool里面。这样就保证了对于某些历史选取的key的idle时间相对来说比较久，但是本次淘汰并没有被选中，因为出现了idle时间更久的key，那么在使用eviction pool的情况下，这种idle时间比较久的key淘汰概率增大了，因为它在eviction pool里面被保存下来，参与下轮淘汰，这个思路和<code>访问局部性原理</code>是契合的。</p><p>因此在只维护一个eviction pool带来的少量开销情况下，对算法效率的提升是比较明显的，效率的提升带来的是访问命中率的提升。</p><h2 id="Redis-的-LFU"><a href="#Redis-的-LFU" class="headerlink" title="Redis 的 LFU"></a>Redis 的 LFU</h2><p>LFU（Least Frequently Used）是在Redis4.0后出现的，LRU的最近最少使用实际上并不精确，考虑下面的情况，如果在|处删除，那么A距离的时间最久，但实际上A的使用频率要比B频繁，所以合理的淘汰策略应该是淘汰B。LFU就是为应对这种情况而生的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A~~A~~A~~A~~A~~A~~A~~A~~A~~A~~~|</span><br><span class="line">B~~~~~B~~~~~B~~~~~B~~~~~~~~~~~B|</span><br></pre></td></tr></table></figure><p>在 Redis 中每个对象都有24 bits空间来记录LRU/LFU信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (高16位用来记录访问时间（单位为分钟），</span></span><br><span class="line"><span class="comment">                            *            低8位用来记录访问频率，简称counter). */</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><h3 id="counter计数器对数因子和衰减时间"><a href="#counter计数器对数因子和衰减时间" class="headerlink" title="counter计数器对数因子和衰减时间"></a>counter计数器对数因子和衰减时间</h3><p>由于 LFU 的基数器只有8bit，所能记录的最大数字为255。因此counter并不是线性增长的，而是用基于概率的对数计数器来实现。counter的增长速度有<code>lfu-log-factor</code>参数控制。但最终counter总会收敛于255，为了解决这个问题，redis还提供了<code>lfu-decay-time</code>衰减因子（单位为分钟），如果一个key长时间未被访问，counter就要减少，减少的幅度由衰减因子来控制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateLFU</span><span class="params">(robj *val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> counter = LFUDecrAndReturn(val);</span><br><span class="line">    counter = LFULogIncr(counter);</span><br><span class="line">    val-&gt;lru = (LFUGetTimeInMinutes()&lt;&lt;<span class="number">8</span>) | counter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 高16位，当server.unixtime超出2^16时，再次从0开始计数 */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">LFUGetTimeInMinutes</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (server.unixtime/<span class="number">60</span>) &amp; <span class="number">65535</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* redis的key的空闲时间(分钟) */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">LFUTimeElapsed</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> ldt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> now = LFUGetTimeInMinutes();</span><br><span class="line">    <span class="keyword">if</span> (now &gt;= ldt) <span class="keyword">return</span> now-ldt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">65535</span>-ldt+now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 在key被访问时，在counter++之前，要根据lfu_decay_time对counter做适当的修减：</span></span><br><span class="line"><span class="comment">  num_periods = 空闲时间/lfu_decay_time &gt; 0</span></span><br><span class="line"><span class="comment">  counter = (num_periods &gt; counter) ? 0 : counter - num_periods;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">LFUDecrAndReturn</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ldt = o-&gt;lru &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> counter = o-&gt;lru &amp; <span class="number">255</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> num_periods = server.lfu_decay_time ? LFUTimeElapsed(ldt) / server.lfu_decay_time : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (num_periods)</span><br><span class="line">        counter = (num_periods &gt; counter) ? <span class="number">0</span> : counter - num_periods;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 基于概率的对数计数器：</span></span><br><span class="line"><span class="comment">  1. 提取0到1之间的随机数R。</span></span><br><span class="line"><span class="comment">  2. 计算counter++的概率 P = 1/(old_value*lfu_log_factor+1).</span></span><br><span class="line"><span class="comment">  3. 如果R &lt; P，则counter++</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LFU_INIT_VAL 5 <span class="comment">//counter的初始值为5，以便给新对象一个机会去积累点击率</span></span></span><br><span class="line"><span class="keyword">uint8_t</span> LFULogIncr(<span class="keyword">uint8_t</span> counter) &#123;</span><br><span class="line">    <span class="keyword">if</span> (counter == <span class="number">255</span>) <span class="keyword">return</span> <span class="number">255</span>;</span><br><span class="line">    <span class="keyword">double</span> r = (<span class="keyword">double</span>)rand()/RAND_MAX;</span><br><span class="line">    <span class="keyword">double</span> baseval = counter - LFU_INIT_VAL;</span><br><span class="line">    <span class="keyword">if</span> (baseval &lt; <span class="number">0</span>) baseval = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> p = <span class="number">1.0</span>/(baseval*server.lfu_log_factor+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (r &lt; p) counter++;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>计数器对数因子<code>lfu-log-factor</code>默认是10，有redis.conf中的这张表可知，默认情况下，当访问次数达到100万时，counter才会增长到255。</li><li>计数器衰减时间<code>lfu-decay-time</code>是一个被衰减的key计数器所必须经过的时间（单位为分钟），默认是1。如果lfu-decay-time = 0，则代表每次在更新counter时，它都要被衰减。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#   redis-benchmark -n 1000000 incr foo</span></span><br><span class="line"><span class="comment">#   redis-cli object freq foo</span></span><br><span class="line"><span class="comment"># +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="comment"># | factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |</span></span><br><span class="line"><span class="comment"># +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="comment"># | 0      | 104        | 255        | 255        | 255        | 255        |</span></span><br><span class="line"><span class="comment"># +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="comment"># | 1      | 18         | 49         | 255        | 255        | 255        |</span></span><br><span class="line"><span class="comment"># +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="comment"># | 10     | 10         | 18         | 142        | 255        | 255        |</span></span><br><span class="line"><span class="comment"># +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="comment"># | 100    | 8          | 11         | 49         | 143        | 255        |</span></span><br><span class="line"><span class="comment"># +--------+------------+------------+------------+------------+------------+</span></span><br></pre></td></tr></table></figure><h2 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h2><p>跟近似的LRU一样，并不是去所有key中寿命最短的那个，而是每次随机取<code>maxmemory-samples</code>个key，删除这里面最即将过期的key。同样在Redis 3.0 之后由于引入了<code>eviction pool</code>数组，使内存淘汰key的策略更公平。</p><p>参考资料：</p><ul><li><a href="https://yq.aliyun.com/articles/63034" target="_blank" rel="noopener">Redis作为LRU Cache的实现</a></li><li><a href="https://yq.aliyun.com/articles/64435" target="_blank" rel="noopener">Redis近似LRU算法优化</a></li><li><a href="https://yq.aliyun.com/articles/643758" target="_blank" rel="noopener">Redis · 引擎特性 · 基于 LFU 的热点 key 发现机制</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;过期删除策略&quot;&gt;&lt;a href=&quot;#过期删除策略&quot; class=&quot;headerlink&quot; title=&quot;过期删除策略&quot;&gt;&lt;/a&gt;过期删除策略&lt;/h1&gt;&lt;p&gt;当Redis中缓存的key过期了，Redis如何处理？&lt;br&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://tianbin.org/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Redis" scheme="https://tianbin.org/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>GeoHash 算法</title>
    <link href="https://tianbin.org/learning/GeoHash/"/>
    <id>https://tianbin.org/learning/GeoHash/</id>
    <published>2019-07-07T04:38:36.000Z</published>
    <updated>2019-07-15T18:10:28.945Z</updated>
    
    <content type="html"><![CDATA[<p>计算「附近的人」，当数据量并发量很小的时候，我们可以直接在数据库中拿到所有点的经纬度信息，然后利用勾股定理依次计算两点间距离，排序。但是当你的数据库里有<strong>几百万个点</strong>的时候，为了提高系统性能，我们可以先以一个点为中心画一个圆，然后计算这个圆中的所有点的距离。但是MySQL的性能毕竟有限，如果并发量也上来呢？<a id="more"></a>恐怕现在还没有那个系统有这么强悍的计算量，因此GeoHash应运而生。</p><p>简单来说，GeoHash可以理解为另一种地址编码方式，它将二维空间的经纬度数据编码成一个字符串，字符串的二进制码值越接近，也说明两个点的实际距离约接近（存在一定的误差）。</p><p><strong>注意</strong>：GeoHash值表示的是一个矩形区域，hash值越长，矩形的范围越小。例如wx4g0ec1，编码wx4g0e表示的范围就比wx4g0ec1更大。所以GeoHash可以用来快速圈定给定坐标的附近坐标。</p><p>此外（题外话）使用GeoHash来表示位置信息，也有助于隐私保护。在线根据GeoHash转换经纬度：<a href="http://geohash.org/wx4g0ec1" target="_blank" rel="noopener">http://geohash.org/{GeoHash}</a></p><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><h2 id="将经纬度转换为二进制"><a href="#将经纬度转换为二进制" class="headerlink" title="将经纬度转换为二进制"></a>将经纬度转换为二进制</h2><p>比如（39.923201, 116.390705）这个点，纬度的范围是（-90，90），其中间值为0。对于纬度39.923201，在区间（0，90）中，因此得到一个1；（0，90）区间的中间值为45度，纬度39.923201小于45，因此得到一个0，依次计算下去，即可得到纬度的二进制表示，如下表：</p><p><img src="http://tb.nsfocus.co/image/geohash_4.png" alt="geohash_4"></p><p>最后得到纬度的二进制表示为：10111000110001111001</p><p>同理可以得到经度116.390705的二进制表示为：11010010110001000100</p><h2 id="合并经度、纬度的二进制"><a href="#合并经度、纬度的二进制" class="headerlink" title="合并经度、纬度的二进制"></a>合并经度、纬度的二进制</h2><p>将经度、纬度二进制按照奇偶位合并。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11100 11101 00100 01111 00000 01101 01011 00001</span><br></pre></td></tr></table></figure><h2 id="按照Base32进行编码"><a href="#按照Base32进行编码" class="headerlink" title="按照Base32进行编码"></a>按照Base32进行编码</h2><p>将上一步合并后的二进制数转换为十进制，然后生成对应的Base32码（0-9,a-z 去掉 a,i,l,o 四个字母）。同理，将编码转换成经纬度的解码算法与之相反，具体不再赘述。</p><p><img src="http://tb.nsfocus.co/image/geohash_base32.png" alt="geohash_base32"></p><p>上述合并后的二进制编码后的结果为：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wx4g0ec1</span><br></pre></td></tr></table></figure><p>由此可见编码越长，表示的范围越小，位置也越精确。<br>下表摘自<a href="https://www.wikiwand.com/en/Geohash#/Number_of_geohash_characters_and_precision_in_km" target="_blank" rel="noopener">维基百科</a>：</p><p><img src="http://tb.nsfocus.co/image/geohash_precision.png" alt="geohash_precision"></p><p>可以看出，当geohash base32编码长度为8时，精度在19米左右，而当编码长度为9时，精度在2米左右，编码长度需要根据数据情况进行选择。</p><h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><blockquote><p>为什么经纬度两串编码是交叉组合成一串编码的？</p></blockquote><p>这就要从GeoHash算法编码原理的起源说起了，简称“二刀法”：将空间划分为四块，编码的顺序分别是左下角00，左上角01，右下脚10，右上角11，也就是类似于Z的曲线，当我们递归的将各个块分解成更小的子块时，编码的顺序是自相似的，每一个子块也形成Z曲线，这种类型的曲线被称为<strong>Peano空间填充曲线</strong>。</p><p><img src="http://tb.nsfocus.co/image/geohash_1.png" alt="geohash_1"><br><img src="http://tb.nsfocus.co/image/geohash_2.png" alt="geohash_2"></p><p>但是Peano空间填充曲线最大的缺点就是突变性，有些编码相邻但距离却相差很远，比如0111与1000，编码是相邻的，但距离相差很大。</p><p>除Peano空间填充曲线外，还有很多空间填充曲线，如图所示，其中效果公认较好是Hilbert空间填充曲线，相较于Peano曲线而言，Hilbert曲线没有较大的突变。为什么GeoHash不选择Hilbert空间填充曲线呢？可能是Peano曲线思路以及计算上比较简单吧，事实上，Peano曲线就是一种四叉树线性编码方式。<br><img src="http://tb.nsfocus.co/image/geohash_3.png" alt="geohash_3"></p><h1 id="使用问题"><a href="#使用问题" class="headerlink" title="使用问题"></a>使用问题</h1><p>Geo 的数据使用单独的 Redis 实例部署，不使用集群环境。因为单个key的数据量有可能很大，不利于集群的迁移。为了降低单个zset集合的大小，可以将数据按国家拆分、按省拆分、按市拆分。(每个省市拆分的时候，记得对边缘点进行一些冗余存储)。</p><h2 id="矩形边缘点问题"><a href="#矩形边缘点问题" class="headerlink" title="矩形边缘点问题"></a>矩形边缘点问题</h2><p>将其相邻的8个区域的点也都加进来，一起算距离。然后排序。</p><h2 id="曲线突变问题"><a href="#曲线突变问题" class="headerlink" title="曲线突变问题"></a>曲线突变问题</h2><p>Peano空间填充曲线，这种曲线会产生突变，造成了编码虽然相似但距离可能相差很大的问题，因此在查询附近餐馆时候，首先筛选GeoHash编码相似的POI点，然后再进行实际距离计算。</p><p>参考资料：</p><ul><li><a href="https://yq.aliyun.com/articles/12" target="_blank" rel="noopener">GeoHash核心原理解析</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算「附近的人」，当数据量并发量很小的时候，我们可以直接在数据库中拿到所有点的经纬度信息，然后利用勾股定理依次计算两点间距离，排序。但是当你的数据库里有&lt;strong&gt;几百万个点&lt;/strong&gt;的时候，为了提高系统性能，我们可以先以一个点为中心画一个圆，然后计算这个圆中的所有点的距离。但是MySQL的性能毕竟有限，如果并发量也上来呢？
    
    </summary>
    
      <category term="学习笔记" scheme="https://tianbin.org/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法" scheme="https://tianbin.org/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Redis" scheme="https://tianbin.org/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 都有哪些数据结构？</title>
    <link href="https://tianbin.org/reading/redis_datastruct/"/>
    <id>https://tianbin.org/reading/redis_datastruct/</id>
    <published>2019-07-06T11:57:45.000Z</published>
    <updated>2019-07-15T18:10:28.948Z</updated>
    
    <content type="html"><![CDATA[<p>字符串String，字段Hash，列表List，集合Set，有序集合ZSet。</p><p>位图、<a href="../../learning/HyperLogLog">HyperLogLog</a>、<a href="../../learning/GeoHash">GeoHash</a>、PubSub、Stream</p><p>Redis Module：RedisBloom、RedisSearch、Redis-Cell</p><a id="more"></a><h1 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h1><p>用于统计用户进1年的签到情况。它的本质还是String，只是Redis天然支持位操作。（直接将byte数组看成「位数组」即可）</p><blockquote><p>setbit key offset value</p><p>getbit key offset</p><p>bitcount key [start] [end]    #统计两个offset之间1的个数</p><p>bittop op destkey [key…]    #对两个位图进行and、or、not、xor操作，将结果保存在destkey中</p><p>bitfield key get/set/incrby</p></blockquote><h1 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h1><p>用于统计页面访问UV、直播在线人数、微博点赞数、微博词条搜索次数，等这些对统计精度要求不是100%，且不需要返回统计集合内所有的元素的场景。<br>原理：<script type="math/tex">N = 2^{k_{max}}</script>，利用每个桶内的<script type="math/tex">k_{max}</script>的调和平均值估计集合的整体基数。</p><blockquote><p>pfadd key element</p><p>pfcount key</p><p>pfmerge [key…]</p></blockquote><p>详情见<a href="../../learning/HyperLogLog">HyperLogLog Counting算法</a></p><h1 id="GeoHash"><a href="#GeoHash" class="headerlink" title="GeoHash"></a>GeoHash</h1><p>Redis 在 3.2 版本以后增加了地理位置 GEO 模块，意味着我们可以使用 Redis 来实现摩拜单车「附近的 Mobike」、饿了么「附近的餐馆」这样的功能了。<br>业界比较通用的地理位置距离排序算法是 <a href="../../learning/GeoHash">GeoHash 算法</a>，Redis 也使用 GeoHash 算法。它将二维的经纬度数据映射成一维的整数，这样所有的元素都将在挂载到一条线上，距离靠近的二维坐标映射到一维后的点之间距离也会很接近。<br>在使用 Redis 进行 Geo 查询时，它的内部结构实际上只是一个 zset(skiplist)。通过 zset 的 score 排序就可以得到坐标附近的其它元素，通过将 score 还原成坐标值就可以得到元素的原始坐标。</p><blockquote><p>geoadd key (longitude) (latitude) (address)</p><p>geodist key (addressA) (addressB) (km)</p><p>geopos key address    #获取元素的经纬度信息</p><p>geohash key address    #获取元素的hash值</p><p>georadiusbymember key address 20 km [withcoord] [withdist] [withhash] count 3 asc # 查询附近20km内最近的3个元素，正序并显示经纬度、距离、hash信息</p></blockquote><h1 id="PubSub（消息多播）"><a href="#PubSub（消息多播）" class="headerlink" title="PubSub（消息多播）"></a>PubSub（消息多播）</h1><p>可以多个客户端订阅同一个消息主题，实现消息多播。但是此模式的缺点就是一旦Redis停机重启，PubSub 的消息是不会持久化的，毕竟 Redis 宕机就相当于一个消费者都没有，所有的消息直接被丢弃。</p><p>Redis5.0 新增的 Stream 数据结构，这个功能给 Redis 带来了持久化消息队列，从此 PubSub 可以消失了</p><h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><p>Stream 的消费模型借鉴了 Kafka 的消费分组的概念，它弥补了 Redis Pub/Sub 不能持久化消息的缺陷。但是它又不同于 kafka，Kafka 的消息可以分 partition，而 Stream 不行。 如果非要分 parition 的话，得在客户端做，提供不同的 Stream 名称，对消息进行 hash 取模来选择往哪个 Stream 里塞。</p><h1 id="RedisBloom（布隆过滤器）"><a href="#RedisBloom（布隆过滤器）" class="headerlink" title="RedisBloom（布隆过滤器）"></a>RedisBloom（布隆过滤器）</h1><p>它说有，不一定有。它说没有，就一定没有。</p><p>因为布隆过滤器的实现原理是利用一个长度为l的位数组，没bf.add一个元素进来，会经过k个hash函数，得到k个不同的位置，然后将这k个位置的数字置位1。当调用bf.exists时，直接去这个key得到的k个hash位置判断是否都为1，有一个位置为0，这判为不存在。但是即使都为0，这个key也不一定存在，因为这k个hash位也有可能是由其他若干个key置位1的。</p><blockquote><p>bf.add key value    # bf.madd key [value…]</p><p>bf.exists key value    # bf.mexists key [value…]</p></blockquote><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p><strong>垃圾邮件的过滤</strong>、今日头条<strong>推荐文章去重</strong>、<strong>爬虫</strong>系统<strong>url去重</strong>（当爬取网页url的数量达到几千万几亿的级别时）等等这种数据量很大，判断key是否存在（去重、过滤），且允许一定几率误判的业务场景。</p><h2 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h2><p>Redis 官方提供的布隆过滤器到了 Redis 4.0 提供了插件功能之后才正式登场。在执行bf.add(key)之前会使用bf.reserve执行显示创建BoolmFIlter，两个个关键参数：</p><ul><li>f（error_rate(0.01)）数字越小，占用空间越大。</li><li>n（initial_size(100)）当key的实际数量超出这个数值时，误判率会上升。</li></ul><p>这两个会直接影响布隆过滤器的数组长度(l)、和hash函数的最佳数量(k)<br>简单的计算公式如下：</p><ul><li>k ≈ 0.7 * <script type="math/tex">\frac{l}{n}</script></li><li>f = <script type="math/tex">0.6185^\frac{l}{n}</script></li></ul><p>公式的证明：<a href="https://www.cnblogs.com/allensun/archive/2011/02/16/1956532.html" target="_blank" rel="noopener">数学学渣慎点</a><br>线上计算空间占用：<a href="https://krisives.github.io/bloom-calculator/" target="_blank" rel="noopener">https://krisives.github.io/bloom-calculator/</a></p><p>误判为什么会上升？</p><h1 id="RedisSearch（全文搜索引擎）"><a href="#RedisSearch（全文搜索引擎）" class="headerlink" title="RedisSearch（全文搜索引擎）"></a>RedisSearch（全文搜索引擎）</h1><h1 id="Redis-Cell"><a href="#Redis-Cell" class="headerlink" title="Redis-Cell"></a>Redis-Cell</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;字符串String，字段Hash，列表List，集合Set，有序集合ZSet。&lt;/p&gt;
&lt;p&gt;位图、&lt;a href=&quot;../../learning/HyperLogLog&quot;&gt;HyperLogLog&lt;/a&gt;、&lt;a href=&quot;../../learning/GeoHash&quot;&gt;GeoHash&lt;/a&gt;、PubSub、Stream&lt;/p&gt;
&lt;p&gt;Redis Module：RedisBloom、RedisSearch、Redis-Cell&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://tianbin.org/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Redis" scheme="https://tianbin.org/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>HyperLogLog Counting 算法</title>
    <link href="https://tianbin.org/learning/HyperLogLog/"/>
    <id>https://tianbin.org/learning/HyperLogLog/</id>
    <published>2019-07-02T18:09:34.000Z</published>
    <updated>2019-07-15T18:10:28.937Z</updated>
    
    <content type="html"><![CDATA[<p>知其然必知其所以然，最近在看redis的义总问了我一个问题：<strong>一个网站的uv是怎么实现的？（当访问量非常大的时候，uv&gt;1000,000,000的时候，还能用redis吗？）</strong>我最近正好搭了这个博客，pv和uv都是直接用的<a href="http://busuanzi.ibruce.info" target="_blank" rel="noopener">不蒜子</a>这个插件，前两天也正好在想他这个uv是怎么实现的？</p><p>于是义总带我走进了HyperLogLog的世界：（以下简称HLL算法）</p><a id="more"></a><p>参考资料：  </p><ul><li><a href="http://www.rainybowe.com/blog/2017/07/13/神奇的HyperLogLog算法/index.html" target="_blank" rel="noopener">神奇的HyperLogLog算法</a></li><li><a href="https://book.douban.com/subject/30386804/" target="_blank" rel="noopener">《Redis 深度历险：核心原理与应用实践》</a></li><li>HLL算法演示：<a href="http://content.research.neustar.biz/blog/hll.html" target="_blank" rel="noopener">http://content.research.neustar.biz/blog/hll.html</a></li></ul><h1 id="HLL算法的使用场景"><a href="#HLL算法的使用场景" class="headerlink" title="HLL算法的使用场景"></a>HLL算法的使用场景</h1><p>HyperLogLog Counting是一种基数计数方法，它的优点：速度极快（常数时间），占用空间极小。缺点：只适用于<strong>统计页面UV(unique visitor)、微博的点赞数</strong>这种对精确度要求不是很高，且不需要返回集合内所有元素的场景。</p><ul><li>已知1亿bit数据，占用空间100000000/8/1024/1024≈12MB。</li><li>假设我们统计的是用户ip地址，每个ip地址占用空间32bit。</li></ul><p>几种基数计数方法，统计1个页面，数据量达到1亿条ip时，所占用的空间及时间复杂度对比：</p><div class="table-container"><table><thead><tr><th></th><th>B树</th><th>Bitmap</th><th>redis的HyperLogLog算法</th></tr></thead><tbody><tr><td>占用空间大小</td><td>32x12 ≈ 384MB</td><td>12MB</td><td><strong><em>12KB</em></strong></td></tr><tr><td>时间复杂度</td><td>O(logN)</td><td>O(N)</td><td><strong><em>O(1)</em></strong></td></tr></tbody></table></div><h2 id="HyperLogLog另一个特性"><a href="#HyperLogLog另一个特性" class="headerlink" title="HyperLogLog另一个特性"></a>HyperLogLog另一个特性</h2><p>想统计今天和昨天两天合起来的uv，HyperLogLog也可以直接取两个天的ip取并集，返回近两天的uv。<br>而其他算法只能重新统计。</p><h1 id="HLL算法原理"><a href="#HLL算法原理" class="headerlink" title="HLL算法原理"></a>HLL算法原理</h1><p>在基数计数方面，HyperLogLog之所以这么牛X，这么神秘，完全是因为它站在了<strong>概率统计</strong>这个巨人的肩膀上，根据<strong>伯努利实验</strong>总结出公式如下：</p><script type="math/tex; mode=display">N = 2^{K_{max}}</script><p>N：整个数据集合里面数据的数量（基数）<br>K：数据集每进来一个元素，对这个元素进行一次二进制hash，k表示hash值第一个1的位置。<br>Kmax：所有这些K中，最大的那个值。（它一定小于等于N）</p><h2 id="（伯努利实验）证明："><a href="#（伯努利实验）证明：" class="headerlink" title="（伯努利实验）证明："></a>（伯努利实验）证明：</h2><p>抛硬币，正面朝上记为1，反面朝上记为0，连续抛X次，第一次出现正面时的投掷次数记为k。这个抛硬币的过程称为伯努利过程。对于n次伯努利过程，我们可以得到n个首次出现正面的投掷次数<script type="math/tex">k_1</script>, <script type="math/tex">k_2</script>……<script type="math/tex">k_n</script>，其中最大值记为<script type="math/tex">k_{max}</script>，那么可以得到下面两个结论：</p><ol><li>n次伯努利过程的首次出现正面的投掷次数都不大于<script type="math/tex">k_{max}</script></li><li>n次伯努利过程，至少有一次的首次出现正面的投掷次数等于<script type="math/tex">k_{max}</script></li></ol><p>对于结论1，用数学公式可以表示为：<script type="math/tex">P_n(X ≤ k_{max}) = (1 - 1/2^{k_{max}})^n</script>，当n ≫ <script type="math/tex">2^{k_{max}}</script>时，<script type="math/tex">P_n(X ≤ k_{max})</script>  ≈ 0。但是<script type="math/tex">P_n(X ≤ k_{max})</script> = 1，所以n不可能远大于<script type="math/tex">2^{k_{max}}</script>。<br>对于结论2，用数学公式可以表示为：<script type="math/tex">P_n(X ≥ k_{max}) = 1 - (1 - 1/2^{k_{max}-1})^n</script>，当n ≪ <script type="math/tex">2^{k_{max}}</script>时，<script type="math/tex">P_n(X ≥ k_{max})</script> ≈ 0。但是<script type="math/tex">P_n(X ≥ k_{max})</script> = 1，所以n也不可能远小于<script type="math/tex">2^{k_{max}}</script>。</p><p>因此我们可以得出结论，n ≈ <script type="math/tex">2^{k_{max}}</script>。</p><h1 id="HLL算法讲解"><a href="#HLL算法讲解" class="headerlink" title="HLL算法讲解"></a>HLL算法讲解</h1><h2 id="分桶平均"><a href="#分桶平均" class="headerlink" title="分桶平均"></a>分桶平均</h2><p>很显然，每次根据抛硬币来推测：我这种情况抛多少次能抛出来。这种“预估方法”误差有点大。<br><strong>因此 HLL算法并不适用于当数据量非常小的时候，统计集合的基数。</strong></p><p>只有当数据量上来的时候，做这种统计估计才有意义。同时HLL算法为了节省空间，引入了分桶平均的概念。基本原理是：将统计数据划分为m个桶（将元素的二进制hash % m），分别统计各个桶的<script type="math/tex">k_{max}</script>值，求调和平均数（所有数的倒数的平均数，可以消除掉极大值和极小值对平均数结果带来的误差），进而得出整个集合的基数预估值 N。</p><p>Java代码实现：<a href="https://github.com/nibnait/algorithm/blob/master/src/main/java/redis/HyperLogLog/HyperLogLogCounting.java" target="_blank" rel="noopener">HyperLogLogCounting</a></p><h2 id="偏差修正"><a href="#偏差修正" class="headerlink" title="偏差修正"></a>偏差修正</h2><p>上述经过分桶平均后的估计量看似已经很不错了，不过通过数学分析可以知道这并不是基数N的无偏估计。这部分的具体数学分析在“<a href="http://algo.inria.fr/flajolet/Publications/DuFl03-LNCS.pdf" target="_blank" rel="noopener">Loglog Counting of Large Cardinalities</a>”中。</p><p>因此需要修正成无偏估计。方法：</p><ol><li>增大桶的数量（增大数组长度）桶越多，每个统计数组越长，误差越小，但存储成本也就越大。</li><li>分阶段修正。</li></ol><h1 id="Redis中HyperLogLog的实现"><a href="#Redis中HyperLogLog的实现" class="headerlink" title="Redis中HyperLogLog的实现"></a>Redis中HyperLogLog的实现</h1><p>Redis应用HyperLogLog的三个命令：<a href="https://redis.io/commands#hyperloglog" target="_blank" rel="noopener">PFADD、PFCOUNT、PFMERGE</a></p><p>Redis 的 HyperLogLog 实现中使用了 16384 个桶，也就是 2^14。<br>每次进来一个元素，对这个元素进行一次二进制hash的长度为64bit，因此每个桶需要用6bit的空间来装这个桶里面的Kmax值。<br>所以总共占用内存就是 2^14 * 6 / 8 = 12k 字节。<br>因为最大可以K值为63，所以redis理论上可以统计的集合的基数的最大值为 2^63。</p><p>同时Redis 对 HyperLogLog 的存储进行了优化，在计数比较小时，它的存储空间采用稀疏矩阵存储，空间占用很小，仅仅在计数慢慢变大，稀疏矩阵占用空间渐渐超过了阈值时才会一次性转变成稠密矩阵，才会占用 12k 的空间。</p><hr><p>附两个数学公式的白话解释</p><p>结论1【n次伯努利过程的首次出现正面的投掷次数都不大于<script type="math/tex">k_{max}</script>】数学公式 <script type="math/tex">P_n(X ≤ k_{max}) = (1 - 1/2^{k_{max}})^n</script> 的白话解释：</p><ul><li>已知1次抛硬币正面朝上的概率为1/2，反面朝上的概率为(1 - 1/2)</li><li>1次伯努利过程，第<script type="math/tex">k_{max}</script>次还没出现正面（前<script type="math/tex">k_{max}</script>次都是反面）的概率为：<script type="math/tex">(1 - 1/2)^{k_{max}}</script> = <script type="math/tex">(1 / 2)^{k_{max}}</script> = <script type="math/tex">1 / 2^{k_{max}}</script></li><li>1次伯努利过程，投掷不大于<script type="math/tex">k_{max}</script>次就出现正面的概率为：<script type="math/tex">1 - 1 / 2^{k_{max}}</script></li><li>n次伯努利过程，投掷不大于<script type="math/tex">k_{max}</script>次就出现正面的概率为：<script type="math/tex">(1 - 1 / 2^{k_{max}})^n</script></li></ul><p>结论2【n次伯努利过程，至少有一次的首次出现正面的投掷次数等于<script type="math/tex">k_{max}</script>】公式<script type="math/tex">P_n(X ≥ k_{max}) = 1 - (1 - 1/2^{k_{max}})^n</script> 的白话解释：</p><ul><li>已知1次伯努利过程，投掷不大于<script type="math/tex">k_{max}</script>次就出现正面的概率为：1 - <script type="math/tex">1 / 2^{k_{max}}</script></li><li>n次伯努利过程，<script type="math/tex">P (至少有一次投掷次数为k_{max})</script><br>= 1 - <script type="math/tex">P(每次投掷次数都小于k_{max})</script><br>= 1 - <script type="math/tex">P(每次投掷次数都 ≤ k_{max} - 1)</script><br>= 1 - <script type="math/tex">P(每次投掷次数都不大于k_{max} - 1)</script><br>= 1 - <script type="math/tex">(1 - 1/2^{k_{max} - 1})^n</script></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;知其然必知其所以然，最近在看redis的义总问了我一个问题：&lt;strong&gt;一个网站的uv是怎么实现的？（当访问量非常大的时候，uv&amp;gt;1000,000,000的时候，还能用redis吗？）&lt;/strong&gt;我最近正好搭了这个博客，pv和uv都是直接用的&lt;a href=&quot;http://busuanzi.ibruce.info&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;不蒜子&lt;/a&gt;这个插件，前两天也正好在想他这个uv是怎么实现的？&lt;/p&gt;
&lt;p&gt;于是义总带我走进了HyperLogLog的世界：（以下简称HLL算法）&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://tianbin.org/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法" scheme="https://tianbin.org/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Redis" scheme="https://tianbin.org/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>关于 Redis</title>
    <link href="https://tianbin.org/reading/redis/"/>
    <id>https://tianbin.org/reading/redis/</id>
    <published>2019-07-02T15:03:28.000Z</published>
    <updated>2019-07-15T18:10:28.947Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Re</strong>mote <strong>Di</strong>ctionary <strong>S</strong>ervice参考资料：  </p><ul><li><a href="https://book.douban.com/subject/30386804/" target="_blank" rel="noopener">《Redis 深度历险：核心原理与应用实践》</a></li><li><a href="https://redis.io/download#installation" target="_blank" rel="noopener">Redis 源码（版本：5.0.5）</a></li></ul><a id="more"></a><h1 id="Redis-都有哪些数据结构？"><a href="#Redis-都有哪些数据结构？" class="headerlink" title="Redis 都有哪些数据结构？"></a><a href="../redis_datastruct">Redis 都有哪些数据结构？</a></h1><h1 id="Redis-过期key删除策略和内存淘汰策略"><a href="#Redis-过期key删除策略和内存淘汰策略" class="headerlink" title="Redis 过期key删除策略和内存淘汰策略"></a><a href="../redis_memory">Redis 过期key删除策略和内存淘汰策略</a></h1><h1 id="关于Redis-高可用"><a href="#关于Redis-高可用" class="headerlink" title="关于Redis 高可用"></a>关于Redis 高可用</h1><h2 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h2><h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><h2 id="Codis-vs-Cluster"><a href="#Codis-vs-Cluster" class="headerlink" title="Codis vs Cluster"></a>Codis vs Cluster</h2><h2 id="限流-时间窗口"><a href="#限流-时间窗口" class="headerlink" title="限流 - 时间窗口"></a>限流 - 时间窗口</h2><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h2 id="Resis漏洞"><a href="#Resis漏洞" class="headerlink" title="Resis漏洞"></a>Resis漏洞</h2><h1 id="线程-IO-模型"><a href="#线程-IO-模型" class="headerlink" title="线程 IO 模型"></a>线程 IO 模型</h1><h1 id="Info指令"><a href="#Info指令" class="headerlink" title="Info指令"></a>Info指令</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Re&lt;/strong&gt;mote &lt;strong&gt;Di&lt;/strong&gt;ctionary &lt;strong&gt;S&lt;/strong&gt;ervice参考资料：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/30386804/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Redis 深度历险：核心原理与应用实践》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://redis.io/download#installation&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Redis 源码（版本：5.0.5）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://tianbin.org/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Redis" scheme="https://tianbin.org/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL - 锁</title>
    <link href="https://tianbin.org/learning/mysql_lock/"/>
    <id>https://tianbin.org/learning/mysql_lock/</id>
    <published>2019-07-01T05:38:06.000Z</published>
    <updated>2019-07-01T11:27:44.840Z</updated>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://www.cnblogs.com/zhoujinyi/p/3435982.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhoujinyi/p/3435982.html</a><br><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html" target="_blank" rel="noopener">https://tech.meituan.com/2014/08/20/innodb-lock.html</a></p><p>MVCC<br>Next-Key Lock</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;a href=&quot;https://www.cnblogs.com/zhoujinyi/p/3435982.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/zhoujinyi/p/3435982.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://tech.meituan.com/2014/08/20/innodb-lock.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://tech.meituan.com/2014/08/20/innodb-lock.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MVCC&lt;br&gt;Next-Key Lock&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://tianbin.org/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="MySQL" scheme="https://tianbin.org/tags/MySQL/"/>
    
      <category term="锁" scheme="https://tianbin.org/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>MySQL - 基本概念</title>
    <link href="https://tianbin.org/learning/mysql_basis/"/>
    <id>https://tianbin.org/learning/mysql_basis/</id>
    <published>2019-07-01T04:38:06.000Z</published>
    <updated>2019-07-01T05:51:38.006Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于存储引擎"><a href="#关于存储引擎" class="headerlink" title="关于存储引擎"></a>关于存储引擎</h1><p>InnoDB存储引擎的特点：支持外键、行级锁、每个表单单独位于一个表空间。</p><a id="more"></a><ul><li>MyISAM和InnoDB的比较：</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">项目</th><th style="text-align:center">MyISAM</th><th style="text-align:center">InnoDB</th></tr></thead><tbody><tr><td style="text-align:center">索引结构</td><td style="text-align:center">B+ 树</td><td style="text-align:center">B- 树</td></tr><tr><td style="text-align:center">事务</td><td style="text-align:center">❌</td><td style="text-align:center">✔️</td></tr><tr><td style="text-align:center">锁粒度</td><td style="text-align:center">表级锁</td><td style="text-align:center">表级锁&amp;行级锁(锁的是索引对应的那一行)</td></tr><tr><td style="text-align:center">外键约束</td><td style="text-align:center">❌</td><td style="text-align:center">✔️</td></tr><tr><td style="text-align:center">表空间大小</td><td style="text-align:center">相对小</td><td style="text-align:center">相对大</td></tr><tr><td style="text-align:center">全文索引</td><td style="text-align:center">✔️</td><td style="text-align:center">❌</td></tr><tr><td style="text-align:center">关注点</td><td style="text-align:center">性能(select)</td><td style="text-align:center">事务(work)</td></tr><tr><td style="text-align:center">数据文件</td><td style="text-align:center">每张MyISAM表存放在三个文件中：<br>元数据：*.frm<br>数据文件：*.MYD<br>索引文件：*.MYI</td><td style="text-align:center">(默认)共享表空间</td></tr><tr><td style="text-align:center">其他</td><td style="text-align:center">支持全文索引、压缩索引</td><td style="text-align:center">不支持</td></tr></tbody></table></div><h1 id="关于索引"><a href="#关于索引" class="headerlink" title="关于索引"></a>关于索引</h1><div class="table-container"><table><thead><tr><th style="text-align:center">项目</th><th style="text-align:center">MyISAM</th><th style="text-align:center">InnoDB</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">升序顺序存储数据，叶子节点保持对应数据行的地址</td><td style="text-align:center">主键节点同时保存数据行，其他辅助索引保存的是主键索引的值</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">键值分离，索引载入内存，数据缓存依赖操作系统</td><td style="text-align:center">键值一起保存，索引与数据一起载入InnoDB缓冲池</td></tr><tr><td style="text-align:center">索引的基数值</td><td style="text-align:center">精确的</td><td style="text-align:center">估计的</td></tr></tbody></table></div><h1 id="事物隔离级别"><a href="#事物隔离级别" class="headerlink" title="事物隔离级别"></a>事物隔离级别</h1><p>参考：<a href="https://www.cnblogs.com/zhoujinyi/p/3437475.html" target="_blank" rel="noopener">MySQL 四种事务隔离级的说明</a>、<br><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html" target="_blank" rel="noopener">Innodb中的事务隔离级别和锁的关系</a></p><div class="table-container"><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">脏读（Dirty Read）</th><th style="text-align:center">不可重复读（NonRepeatable Read）</th><th style="text-align:center">幻读（Phantom Read）</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">未提交读（Read uncommitted）</td><td style="text-align:center">✔️</td><td style="text-align:center">✔️</td><td style="text-align:center">✔️</td><td style="text-align:center">允许脏读，也就是可能读取到其他会话中未提交事务修改的数据</td></tr><tr><td style="text-align:center">已提交读（Read committed）</td><td style="text-align:center">❌</td><td style="text-align:center">✔️</td><td style="text-align:center">✔️</td><td style="text-align:center">只能读取到已经提交的数据。Oracle等多数数据库默认级别 (不重复读)</td></tr><tr><td style="text-align:center">可重复读（Repeatable read）</td><td style="text-align:center">❌</td><td style="text-align:center">❌</td><td style="text-align:center">✔️</td><td style="text-align:center">可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。</td></tr><tr><td style="text-align:center">可串行化（Serializable ）</td><td style="text-align:center">❌</td><td style="text-align:center">❌</td><td style="text-align:center">❌</td><td style="text-align:center">完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞</td></tr></tbody></table></div><h2 id="脏读（Dirty-Read）"><a href="#脏读（Dirty-Read）" class="headerlink" title="脏读（Dirty Read）"></a>脏读（Dirty Read）</h2><p>脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</p><h2 id="不可重复读（NonRepeatable-Read）-已提交读（Read-committed）"><a href="#不可重复读（NonRepeatable-Read）-已提交读（Read-committed）" class="headerlink" title="不可重复读（NonRepeatable Read）/ 已提交读（Read committed）"></a>不可重复读（NonRepeatable Read）/ 已提交读（Read committed）</h2><p>是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。</p><h2 id="可重复读（Repeatable-read）"><a href="#可重复读（Repeatable-read）" class="headerlink" title="可重复读（Repeatable read）"></a>可重复读（Repeatable read）</h2><p>本身，可重复读和提交读是矛盾的。在同一个事务里，如果保证了可重复读，就会看不到其他事务的提交，违背了提交读；如果保证了提交读，就会导致前后两次读到的结果不一致，违背了可重复读。</p><p>可以这么讲，InnoDB提供了这样的机制，在默认的可重复读的隔离级别里，可以使用加锁读去查询最新的数据。</p><h2 id="幻读（Phantom-Read）"><a href="#幻读（Phantom-Read）" class="headerlink" title="幻读（Phantom Read）"></a>幻读（Phantom Read）</h2><p>第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。</p><p><strong>当隔离级别是可重复读，且禁用innodb_locks_unsafe_for_binlog的情况下，在搜索和扫描index的时候使用的<a href="https://www.cnblogs.com/zhoujinyi/p/3435982.html" target="_blank" rel="noopener">next-key locks</a>可以避免幻读。</strong></p><h1 id="附：CentOS安装大法"><a href="#附：CentOS安装大法" class="headerlink" title="附：CentOS安装大法"></a>附：CentOS安装大法</h1><blockquote><ul><li>yum –y install mysql </li><li>yum –y install mysql -server</li><li>service mysqld start    //启动</li><li>/usr/bin/mysqladmin –u root password ‘root’        //设置密码 </li><li>mysql –u root –p            //进入<ul><li>use mysql;</li><li>select host,user,password from user;</li><li>delete from user where password=’’;  </li></ul></li></ul></blockquote><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/mysqladmin -u root password &apos;new-password&apos;</span><br><span class="line">/usr/bin/mysqladmin -u root -h vultr.guest password &apos;new-password&apos;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关于存储引擎&quot;&gt;&lt;a href=&quot;#关于存储引擎&quot; class=&quot;headerlink&quot; title=&quot;关于存储引擎&quot;&gt;&lt;/a&gt;关于存储引擎&lt;/h1&gt;&lt;p&gt;InnoDB存储引擎的特点：支持外键、行级锁、每个表单单独位于一个表空间。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://tianbin.org/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="MySQL" scheme="https://tianbin.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Valine 初始化头像</title>
    <link href="https://tianbin.org/trying/d6b91886-valine_avatar/"/>
    <id>https://tianbin.org/trying/d6b91886-valine_avatar/</id>
    <published>2019-06-30T07:56:25.000Z</published>
    <updated>2019-07-15T18:10:28.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><ol><li>添加了Valine评论插件后，发现评论者的头像是在_config.yml里面设置一种样式。  </li><li>如果想改头像只能去<a href="http://cn.gravatar.com/" target="_blank" rel="noopener">Gravatar</a>自行注册账号修改头像。（<a href="https://valine.js.org/avatar.html" target="_blank" rel="noopener">https://valine.js.org/avatar.html</a>）</li><li>默认头像如果评论多了的时候，好难看：</li></ol><a id="more"></a><p><img src="http://tb.nsfocus.co/image/d6b91886-before.png" alt="改造前"></p><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>本地初始化头像，使相同昵称、相同邮箱的评论者，展示相同的头像。<br>且 兼容远程头像（用户自己去Gravatar设置过头像的，展示用户自己的头像）</p><h1 id="行动"><a href="#行动" class="headerlink" title="行动"></a>行动</h1><p>（上述目标，其实是在经过2个小时采坑填坑之后的最终结果）<br>大致说下采坑过程，与解题思路。感谢舍友的大力支持，不然我这前端小白2天都搞不定。/捂脸</p><p>先Google，发现个类似问题：<a href="https://www.bliner.me/2018/07/hexo_avatar_initialization/" target="_blank" rel="noopener">Hexo使用Valine评论系统不显示自定义头像的解决方案</a></p><p>让我知道了Valine的头像是有一组值的</p><pre><code>ds: [&quot;mp&quot;, &quot;identicon&quot;, &quot;monsterid&quot;, &quot;wavatar&quot;, &quot;robohash&quot;, &quot;retro&quot;, &quot;&quot;],</code></pre><p>这就让我有了一个大胆的想法：就用这几个官方头像模板初始化。</p><h2 id="获取官方最新的Valine-min-js文件"><a href="#获取官方最新的Valine-min-js文件" class="headerlink" title="获取官方最新的Valine.min.js文件"></a>获取官方最新的<a href="https://unpkg.com/valine@1.3.9/dist/Valine.min.js" target="_blank" rel="noopener">Valine.min.js文件</a></h2><h2 id="开始改造"><a href="#开始改造" class="headerlink" title="开始改造"></a>开始改造</h2><p>过程就不详细记录了，大致说下踩到的几个坑：</p><ol><li>直接随机显示ds数组里的这几个头像，带来的问题：相同昵称（同一个人）头像可能不一样</li><li>拿到的是Valine.min.js压缩过的js，美化后（格式化），无法解析。必须直接去压缩文件中修改js代码</li><li>换个思路，将ds数组随机的值，与评论者的昵称做匹配。<br> 看了下Valine的源码：<a href="https://github.com/xCss/Valine/blob/master/src/index.js" target="_blank" rel="noopener">https://github.com/xCss/Valine/blob/master/src/index.js</a><br> 原来这个头像链接的组成是这样的：</li></ol><pre><code>`&lt;img class=&quot;vimg&quot; src=&quot;${_avatarSetting[&#39;cdn&#39;]+md5(rt.get(&#39;mail&#39;))+_avatarSetting[&#39;params&#39;]}&quot;&gt;`;                   src=&quot;https://gravatar.loli.net/avatar/d41d8cd98f00b204e9800998ecf8427e?d=mp&amp;v=1.3.9&quot;【cdn url】 + 【mail的md5（用于查询用户自定义的头像）】 + 【config.yml中配置的默认头像】 + 【version】</code></pre><ol><li>那我只需要把第三部分一改：根据nick的md5值，随机一个0-5的数字，返回ds数组中对应的值。</li></ol><pre><code>_nick = a(e.get(&quot;nick&quot;)),_res = _nick.match(/(\d)/)[1],_seed = _res ? Math.floor(_res / 2) : &#39;5&#39;,o = m.hide ? &quot;&quot; : &#39;&lt;img class=&quot;vimg&quot; src=&quot;&#39; + (m.cdn + a(e.get(&quot;mail&quot;))    +&quot;?d=&quot;+(m.ds[_seed] || &quot;mp&quot;) + &#39;&amp;v&#39; + m.params.split(&quot;&amp;v&quot;)[1]) + &#39;&quot;&gt;&#39;,</code></pre><p>大功告成：<a href="http://tb.nsfocus.co/js/Valine.min_7.js" target="_blank" rel="noopener">My Valine.min.js文件</a></p><h1 id="改造后"><a href="#改造后" class="headerlink" title="改造后"></a>改造后</h1><p><img src="http://tb.nsfocus.co/image/d6b91886-after.png" alt="改造后"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;添加了Valine评论插件后，发现评论者的头像是在_config.yml里面设置一种样式。  &lt;/li&gt;
&lt;li&gt;如果想改头像只能去&lt;a href=&quot;http://cn.gravatar.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Gravatar&lt;/a&gt;自行注册账号修改头像。（&lt;a href=&quot;https://valine.js.org/avatar.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://valine.js.org/avatar.html&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;默认头像如果评论多了的时候，好难看：&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="搞点事情" scheme="https://tianbin.org/categories/%E6%90%9E%E7%82%B9%E4%BA%8B%E6%83%85/"/>
    
    
      <category term="hexo" scheme="https://tianbin.org/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>JVM 实战</title>
    <link href="https://tianbin.org/learning/jvm_action/"/>
    <id>https://tianbin.org/learning/jvm_action/</id>
    <published>2019-06-29T19:31:35.000Z</published>
    <updated>2019-07-15T18:10:28.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用的Jvm启动参数"><a href="#常用的Jvm启动参数" class="headerlink" title="常用的Jvm启动参数"></a>常用的Jvm启动参数</h1><ul><li>-Xmx512m：设置JVM最大可用内存为512M。</li><li>-Xms512m：设置JVM初始内存为512m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。<a id="more"></a></li><li><p>-Xmn200m：设置年轻代大小为200M。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8（young占30%左右）</p></li><li><p>-verbose:gc：开启gc日志</p></li><li>-Xloggc:gcc.log：将日志输出到文件xx(默认位置为桌面)</li><li>-XX:+PrintGCDetails：打印GC详情</li><li>-XX:+PrintGCDateStamps：打印GC时间戳 </li></ul><p>参考：<br><a href="https://blog.csdn.net/renfufei/column/info/14851" target="_blank" rel="noopener">GC性能优化</a><br><a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html" target="_blank" rel="noopener">美团 - 从实际案例聊聊Java应用的GC优化</a></p><h1 id="FGC实战"><a href="#FGC实战" class="headerlink" title="FGC实战"></a>FGC实战</h1><p>以JxlTest为例，通过gc日志，fix FGC问题。参考<a href="https://mp.weixin.qq.com/s/0VeZYuoMG8PimeHk4CbjTQ" target="_blank" rel="noopener">阿飞的博客-FGC实战</a></p><p>阅读一下GC日志</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;常用的Jvm启动参数&quot;&gt;&lt;a href=&quot;#常用的Jvm启动参数&quot; class=&quot;headerlink&quot; title=&quot;常用的Jvm启动参数&quot;&gt;&lt;/a&gt;常用的Jvm启动参数&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;-Xmx512m：设置JVM最大可用内存为512M。&lt;/li&gt;
&lt;li&gt;-Xms512m：设置JVM初始内存为512m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。
    
    </summary>
    
      <category term="学习笔记" scheme="https://tianbin.org/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JVM" scheme="https://tianbin.org/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java 虚拟机 - 概念</title>
    <link href="https://tianbin.org/reading/6f8dd084-JVM/"/>
    <id>https://tianbin.org/reading/6f8dd084-JVM/</id>
    <published>2019-06-29T19:01:35.000Z</published>
    <updated>2019-07-15T18:10:28.946Z</updated>
    
    <content type="html"><![CDATA[<p>书单列表：  </p><ul><li><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">《深入理解Java虚拟机（第2版）》</a></li><li><a href="https://book.douban.com/subject/26354292/" target="_blank" rel="noopener">《实战Java虚拟机》</a></li></ul><p>目录：</p><ul><li>Java虚拟机的基本结构  </li><li>常用的垃圾回收算法  <a id="more"></a><ol><li>引用计数法</li><li>标记清除法</li><li>复制算法</li><li>标记压缩法</li><li>分代算法</li><li>分区算法  </li></ol></li><li>垃圾回收器  <ol><li>串行回收器</li><li>并行回收器</li><li>CMS回收器</li><li>G1回收器  </li></ol></li><li>Class装载系统  <ol><li>类装载步骤</li><li>双亲委托模式</li></ol></li><li>字节码执行<ol><li>Class文件结构</li><li>JIT</li></ol></li></ul><h1 id="Java虚拟机的基本结构"><a href="#Java虚拟机的基本结构" class="headerlink" title="Java虚拟机的基本结构"></a>Java虚拟机的基本结构</h1><p><img src="http://tb.nsfocus.co/image/6f8dd084-1.png" alt="Java虚拟机的基本结构"></p><ul><li>Java栈：由<strong>栈帧</strong>组成，一个函数对应一个栈帧(函数被调用—&gt;入栈)，[栈顶—-当前正在运行的函数]，[弹栈—&gt;①函数正常return;②Exception]<img src="http://tb.nsfocus.co/image/6f8dd084-2.png" alt="栈帧的结构"></li><li>方法区：<ul><li>JDK1.6、1.7 ==&gt; 又叫永久区(Perm)</li><li>JDK1.8 ==&gt; 叫元数据区(Metaspace)，(默认 可以吃掉所有系统可用内存)</li></ul></li></ul><h1 id="常用的垃圾回收算法"><a href="#常用的垃圾回收算法" class="headerlink" title="常用的垃圾回收算法"></a>常用的垃圾回收算法</h1><p>“垃圾”：内存中，不会再被使用的对象。</p><h2 id="1-引用计数法"><a href="#1-引用计数法" class="headerlink" title="1. 引用计数法"></a>1. 引用计数法</h2><pre><code>==&gt;缺点：①无法处理循环引用；②&#39;+&#39;、&#39;-&#39;计数器浪费性能</code></pre><h2 id="2-标记清除法"><a href="#2-标记清除法" class="headerlink" title="2. 标记清除法"></a>2. 标记清除法</h2><ul><li>标记：标记从 <em>根节点</em> 开始的所有可达对象  </li><li><p>清除：清除所有未被标记的对象</p><p> ==&gt;缺点：回收后的空间不是连续的，在给大对象分配堆空间时 效率低。</p></li></ul><h2 id="3-复制算法-适用于-存活对象少，垃圾对象比较多的新生代"><a href="#3-复制算法-适用于-存活对象少，垃圾对象比较多的新生代" class="headerlink" title="3. 复制算法(适用于 存活对象少，垃圾对象比较多的新生代)"></a>3. 复制算法(适用于 存活对象少，垃圾对象比较多的新生代)</h2><pre><code>例：将内存(Java堆)平均分为两块A、B，每次清理只需要将A中存活的对象复制到B中，然后清空A。  从而解决了 回收后空间不连续的问题</code></pre><h2 id="4-标记压缩清除法-适用于老年代"><a href="#4-标记压缩清除法-适用于老年代" class="headerlink" title="4. 标记压缩清除法(适用于老年代)"></a>4. 标记压缩清除法(适用于老年代)</h2><ul><li>标记 从 <em>根节点</em> 开始的所有可达对象</li><li>压缩到内存的一端</li><li>清除边界外的所有垃圾</li></ul><h2 id="5-分代算法"><a href="#5-分代算法" class="headerlink" title="5. 分代算法"></a>5. 分代算法</h2><pre><code>即 新生代用“**改良的复制算法**”，老年代用“**标记压缩清除法**”![改良的复制算法](http://tb.nsfocus.co/image/6f8dd084-3.png) - 栈上分配：基于逃逸分析技术，将线程私有的*小对象*打散分配到Java栈上。（函数调用结束后，会自行销毁，不需要垃圾回收器介入从而提高了性能） - 逃逸分析：对象的作用域未逃出函数体(-server模式下 默认开启) - TLAB（Thread-local allocation buffer）：线程本地分配缓存(是一个线程专用的内存分配)。（实质：线程专属区间 ⊂ Eden区间） - 在老年代引入**卡表**(比特位集合，每一位表示老年代的4k空间)，（1：有被新生代引用的对象，0：无,,,,,,）以应对新生代的高频率GC，每次只需扫描卡表中为1的空间即可。</code></pre><h2 id="6-分区算法"><a href="#6-分区算法" class="headerlink" title="6. 分区算法"></a>6. 分区算法</h2><pre><code>将整个堆划分成连续的不同的小区间，每个小区间独立使用，独立回收。  从而能够更好地控制一次GC产生的停顿时间</code></pre><h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><div class="table-container"><table><thead><tr><th style="text-align:center">回收器</th><th style="text-align:center">串行/并行</th><th style="text-align:center">算法</th><th style="text-align:center">特点</th></tr></thead><tbody><tr><td style="text-align:center">新生代串行回收器</td><td style="text-align:center">单线程</td><td style="text-align:center">复制算法</td><td style="text-align:center">实现简单 逻辑处理高效</td></tr><tr><td style="text-align:center">老年代串行回收器</td><td style="text-align:center">单线程</td><td style="text-align:center">标记压缩清除</td><td style="text-align:center">(堆空间较大时)停顿时间长</td></tr><tr><td style="text-align:center">新生代ParNew回收器</td><td style="text-align:center">多线程</td><td style="text-align:center">复制算法</td><td style="text-align:center">性能要看CPU的并发能力</td></tr><tr><td style="text-align:center">新生代ParallelGC回收器</td><td style="text-align:center">多线程</td><td style="text-align:center">复制算法</td><td style="text-align:center">[MaxGCPauseMillis]<br>[GCTimeRatio]<br> <strong>关注吞吐量</strong></td></tr><tr><td style="text-align:center">老年代ParallelGC回收器</td><td style="text-align:center">多线程</td><td style="text-align:center">标记压缩清除</td><td style="text-align:center"><strong>关注吞吐量</strong></td></tr></tbody></table></div><h2 id="1-CMS回收器-关注系统停顿时间"><a href="#1-CMS回收器-关注系统停顿时间" class="headerlink" title="1. CMS回收器[关注系统停顿时间]"></a>1. CMS回收器[<strong>关注系统停顿时间</strong>]</h2><pre><code>（Concurrent Mark Sweep）并发标记清除</code></pre><ul><li>初始标记：【STW】 标记根对象</li><li>并发标记：标记所有可达对象</li><li>预清理：正式清理前的准备和检查(并发)，尝试控制一次停顿时间</li><li>重新标记：【STW】 修正<em>并发标记</em></li><li>并发清理：(并发)回收垃圾对象</li><li>并发充值：重新初始化CMS数据结构和数据</li></ul><h2 id="2-G1回收器-Garbage-First"><a href="#2-G1回收器-Garbage-First" class="headerlink" title="2. G1回收器(Garbage First)"></a>2. G1回收器(Garbage First)</h2><p><img src="http://tb.nsfocus.co/image/6f8dd084-4.png" alt></p><ul><li>新生代GC：回收处理Eden和SurvivorA区。==&gt; 老年代的区域增多</li><li>并发标记周期：<br><img src="http://tb.nsfocus.co/image/6f8dd084-5.png" alt><br>SATB(Snapshot-At-The-beginning)：在初始标记时为存活对象建立的快照</li><li>混合回收<ul><li>正常的年轻代GC(改良的复制算法)</li><li>优先清理回收集中垃圾比例较高的区域</li></ul></li><li>必要时的Full GC（回收时，内存不足的时候）<ul><li>新生代GC时，survivor区和老年代区无法容纳幸存对象时</li><li>并发标记时，老年代被快速填充</li><li>混合GC时，发生空间不足</li></ul></li></ul><h1 id="Class装载系统"><a href="#Class装载系统" class="headerlink" title="Class装载系统"></a>Class装载系统</h1><h2 id="1-类装载步骤"><a href="#1-类装载步骤" class="headerlink" title="1. 类装载步骤"></a>1. 类装载步骤</h2><p><img src="http://tb.nsfocus.co/image/6f8dd084-6.png" alt="类装载步骤"></p><pre><code> - 加载：解析类方法区内的数据结构 并创建实例 - 验证：class文件格式、语义检查、字节码验证、符号引用验证... - 准备：为类在Java堆中分配空间，设置初始值 - 解析：将 类、接口、字段、方法的符号引用转为直接引用 - 初始化：编译器自动生成并执行类的初始化方法```&lt;clinit&gt;```（方法```&lt;clinit&gt;```由类静态成员的赋值语句和static语句块合并产生）</code></pre><h2 id="2-双亲委托模式-系统默认使用"><a href="#2-双亲委托模式-系统默认使用" class="headerlink" title="2. 双亲委托模式(系统默认使用)"></a>2. 双亲委托模式(系统默认使用)</h2><p><img src="http://tb.nsfocus.co/image/6f8dd084-7.png" alt="双亲委托模式"></p><p>在类加载的时候，</p><pre><code>if（当前类已经被加载）{      return 当前可用类;  } else {      请求其双亲加载器加载此类；      if（success）{          return 可用的类；      } else{          自己加载；          return 类；      }  }  </code></pre><h2 id="字节码执行"><a href="#字节码执行" class="headerlink" title="字节码执行"></a>字节码执行</h2><hr><p>本文为原创文章，包含脚本行为，会经常更新知识点以及修正一些错误，因此转载请保留原出处，方便溯源，避免陈旧错误知识的误导，同时有更好的阅读体验。<br>本文地址：<a href="http://nibnait.com/6f8dd084-about-Java-Virtual-Machine/" target="_blank" rel="noopener">http://nibnait.com/6f8dd084-about-Java-Virtual-Machine/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;书单列表：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/24722612/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《深入理解Java虚拟机（第2版）》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/26354292/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《实战Java虚拟机》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java虚拟机的基本结构  &lt;/li&gt;
&lt;li&gt;常用的垃圾回收算法
    
    </summary>
    
      <category term="读书笔记" scheme="https://tianbin.org/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JVM" scheme="https://tianbin.org/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络发展史</title>
    <link href="https://tianbin.org/reading/c500696f-computer_networking_history/"/>
    <id>https://tianbin.org/reading/c500696f-computer_networking_history/</id>
    <published>2019-06-29T18:57:52.000Z</published>
    <updated>2019-07-15T18:10:28.947Z</updated>
    
    <content type="html"><![CDATA[<p>首先分享一段 <a href="http://v.youku.com/v_show/id_XNjU3MTE2MTY=.html" target="_blank" rel="noopener">《互联网 发展 历史》 的8分钟小视频</a> </p><a id="more"></a><iframe height="498" width="510" src="http://player.youku.com/embed/XNjU3MTE2MTY=" frameborder="0" allowfullscreen></iframe><p>概念：将一个个独立的计算机连接起来，即组成了计算机网络。<br>再结合这张图，不难看出 计算机的发展史，也就是计算机网络的发展史<br><img src="http://tb.nsfocus.co/image/c500696f-1.png" alt="《图解TCP/IP》 P10 表1.1"></p><h1 id="计算机网络的基础知识"><a href="#计算机网络的基础知识" class="headerlink" title="计算机网络的基础知识"></a>计算机网络的基础知识</h1><p>在计算机网络发展的初期，各家计算机厂商都发明了一套自己的计算机通信协议，不同品牌的计算机无法进行通信，于是ISO▼制定了一个国际标准 OSI协议。  </p><p>OSI七层参考模型▼：  </p><p><img src="http://tb.nsfocus.co/image/c500696f-2.png" alt="《图解TCP/IP》 P20 图1.19"></p><h2 id="搭建网络的主要设备"><a href="#搭建网络的主要设备" class="headerlink" title="搭建网络的主要设备"></a>搭建网络的主要设备</h2><div class="table-container"><table><thead><tr><th style="text-align:left">设备</th><th style="text-align:left">别名</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">网卡</td><td style="text-align:left">NIC▼/网络适配器/LAN卡</td><td style="text-align:left">使计算机连网</td></tr><tr><td style="text-align:left">中继器(Repeater)</td><td style="text-align:left">集线器(Hub)==多口中继器</td><td style="text-align:left">在物理层，将减弱的信号放大并发送</td></tr><tr><td style="text-align:left">网桥(Bridge)</td><td style="text-align:left">2层交换机/以太网交换机/链路层交换机/交换集线器(具有网桥功能的Hub)</td><td style="text-align:left">在数据链路层，校验并转发 数据帧 （将损坏的数据直接丢弃）（ 传送门：<a href="http://nibnait.com/d4c81fd3-error-detection-and-correction/" target="_blank" rel="noopener">各种校验-CRC▼</a>）</td></tr><tr><td style="text-align:left">路由器(Router)</td><td style="text-align:left">3层交换机</td><td style="text-align:left">在网络层，通过IP协议根据IP地址对 数据报 进行转发</td></tr><tr><td style="text-align:left">4~7层交换机</td><td style="text-align:left"></td><td style="text-align:left">· 负载均衡<br>· 防火墙(网关)<br>· 带宽控制(优先处理一些及时性要求比较高的通信请求：语音通话)<br>· 特殊应用访问加速、广域网加速器….</td></tr><tr><td style="text-align:left">网关(Gateway)</td><td style="text-align:left"></td><td style="text-align:left">· 协议的转换(表示层)与数据的转发(4~7层)</td></tr><tr><td style="text-align:left">应用网关</td><td style="text-align:left">代理服务器</td><td style="text-align:left">· 是网关的一种<br>· 可以从传输层到应用层对数据和访问进行各种控制和处理</td></tr></tbody></table></div><h2 id="传输方式的分类"><a href="#传输方式的分类" class="headerlink" title="传输方式的分类"></a>传输方式的分类</h2><h3 id="1-面向有连接型与面向无连接型"><a href="#1-面向有连接型与面向无连接型" class="headerlink" title="1. 面向有连接型与面向无连接型"></a>1. 面向有连接型与面向无连接型</h3><ul><li>面向有连接型<ul><li>TCP</li><li>打电话建##立/断开连接的时候、</li></ul></li><li>面向无连接型<ul><li>UDP、IP</li><li>邮局寄包裹(不需要确认收件人的详细地址是否真实存在)、视频/语音通信的过程(没有必要保证每一帧都成功的传送到达目的地)、</li></ul></li></ul><h3 id="2-电路交换与分组交换"><a href="#2-电路交换与分组交换" class="headerlink" title="2. 电路交换与分组交换"></a>2. 电路交换与分组交换</h3><ul><li><p>电路交换</p><ul><li>主要用于：过去的<strong>电话网</strong>。</li><li>两台主机通信时 是独占整个电路的。同一电路的其他多台计算机只能等待正在通信的计算机收发信息完毕以后 才有机会使用这条电路。</li></ul></li><li><p>分组交换</p><ul><li>主要用于：<strong>现代计算机网络</strong></li><li>处理过程：发送端计算机将数据分组发送给路由器，路由器收到这些分组数据以后，缓存到自己的缓冲区，然后再转发给目标计算机</li><li>限制：根据网络的拥堵情况，数据到达目标地址的时间有长有短。路由器的缓存饱和或溢出时，容易造成数据丢失。</li></ul></li></ul><h3 id="3-按接收端的数量分类"><a href="#3-按接收端的数量分类" class="headerlink" title="3. 按接收端的数量分类"></a>3. 按接收端的数量分类</h3><ul><li>单播(Unicast)<ul><li>1v1通信，打电话。</li></ul></li><li>广播(Broadcast)：同一数据链路内的所有主机<ul><li>电视频道、收音机频道。</li></ul></li><li>多播(Muticast)：与特定组内的计算机通信<ul><li>电话/视频会议</li><li>“1年1班的同学们，请起立！”</li></ul></li><li>任播(Anycast)：解析特定组内的任意一台计算机<ul><li>DNS根域名解析服务器(负载均衡)</li><li>“1年1班的哪位同学上来领一下奖状？”</li><li>“飞机上哪位乘客是医生？”</li></ul></li></ul><hr><p>本文中提到的一些专有名词：</p><ul><li>ISO：国际标准化组织(International Organization for Standards)</li><li>OSI：开放式通信系统互联参考模型(Open System Interconnection)</li><li>NIC：网络接口卡(Network Interface Card)</li><li>CRC：循环冗余校验(Cyclic Redundancy Check)</li><li>WAN：广域网(Wide Area Netword)</li><li>LAN：局域网(Local Area Network)</li><li>Internet：网际网（WAN√、LAN√）</li><li>The Internet：互联网</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先分享一段 &lt;a href=&quot;http://v.youku.com/v_show/id_XNjU3MTE2MTY=.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《互联网 发展 历史》 的8分钟小视频&lt;/a&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://tianbin.org/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="网络" scheme="https://tianbin.org/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络 - 进阶</title>
    <link href="https://tianbin.org/reading/b3dcfa99-computer_networking_advance/"/>
    <id>https://tianbin.org/reading/b3dcfa99-computer_networking_advance/</id>
    <published>2019-06-29T18:49:16.000Z</published>
    <updated>2019-07-15T18:10:28.947Z</updated>
    
    <content type="html"><![CDATA[<p>目录：</p><ol><li><p>网络层</p><ul><li>IP多播</li><li>IP隧道 </li><li>IPv6的地址结构</li><li>路径MTU发现</li><li>ICMP报文消息类型详解</li><li>ICMPv6的邻居探索</li></ul></li></ol><a id="more"></a><h1 id="1-网络层"><a href="#1-网络层" class="headerlink" title="1. 网络层"></a>1. 网络层</h1><h2 id="IP多播："><a href="#IP多播：" class="headerlink" title="IP多播："></a>IP多播：</h2><p><img src="http://tb.nsfocus.co/image/b3dcfa99-1.png" alt></p><p>附：<a href="http://tb.nsfocus.co/image/b3dcfa99-2.png" target="_blank" rel="noopener">既定已知的多播地址.png</a></p><h2 id="IP隧道"><a href="#IP隧道" class="headerlink" title="IP隧道"></a>IP隧道</h2><p><img src="http://tb.nsfocus.co/image/b3dcfa99-3.png" alt></p><p>用处：</p><ul><li>MobileIP</li><li>多播包的转播（使用IP隧道，使路由器用单播的形式发包）</li><li>IPv4网络中传送IPv6的包 √</li><li>IPv6网络中传送IPv4的包 √</li><li>将数据链路的PPP包用IP包转发时</li></ul><h2 id="IPv6的地址结构"><a href="#IPv6的地址结构" class="headerlink" title="IPv6的地址结构"></a>IPv6的地址结构</h2><p><img src="http://tb.nsfocus.co/image/b3dcfa99-4.png" alt></p><h2 id="路径MTU发现"><a href="#路径MTU发现" class="headerlink" title="路径MTU发现"></a>路径MTU发现</h2><p><img src="http://tb.nsfocus.co/image/b3dcfa99-5.png" alt></p><h2 id="ICMP报文消息类型详解"><a href="#ICMP报文消息类型详解" class="headerlink" title="ICMP报文消息类型详解"></a>ICMP报文消息类型详解</h2><ul><li><p>ICMP目标不可达消息（类型3）</p><ul><li>错误代码1（主机不可达）：路由表中没有该主机信息，或该主机(关机)没有连接到网络</li><li>错误代码2（协议不可达）(Protocol Unreachable)</li><li>错误代码3（端口不可达）(Port Unreachable)</li><li>错误代码4（Fragmentation Needed and Don’t Fragment was Set）：用于MTU探索</li></ul></li><li><p>ICMP重定向消息（类型5）</p></li></ul><p><img src="http://tb.nsfocus.co/image/b3dcfa99-6.png" alt></p><ul><li><p>ICMP超时消息（类型11）</p><p>  当TTL==0时，IP路由器就会给发送端主机返回一个 ICMP超时消息。<br> 应用：tracerouter。<br><img src="http://tb.nsfocus.co/image/b3dcfa99-7.png" alt></p></li><li><p>ICMP回送消息（类型0、8）</p><p> 用于进行通信的主机或路由器之间，判断所发送的数据包是否已经成功到达对端的一种消息。<br> 应用：ping命令。</p></li><li><p>ICMP路由探索消息（类型9、10）</p><p> 主要用于发现与自己相连的网络中的路由器。当一台主机发出ICMP路由请求（Router Solicitaion，类型10）时，路由器则返回ICMP路由器通告消息（Router Advertisement，类型9）给主机。</p></li><li><p>ICMP地址掩码消息（类型17、18）</p><p> 主要用于主机或路由器想要了解子网掩码的情况。可以向那些目标主机或路由器发送ICMP地址掩码请求消息（ICMP Address Mask Request，类型17），然后通过接收ICMP地址掩码应答消息（ICMP Address Mask Reply，类型18）获取子网掩码的信息。</p></li></ul><h2 id="ICMPv6的邻居探索"><a href="#ICMPv6的邻居探索" class="headerlink" title="ICMPv6的邻居探索"></a>ICMPv6的邻居探索</h2><p><img src="http://tb.nsfocus.co/image/b3dcfa99-9.png" alt></p><p>附：<a href="http://tb.nsfocus.co/image/b3dcfa99-10.png" target="_blank" rel="noopener">ICMPv6常用的报文消息类型</a></p><hr><p>本文中提到的一些专有名词：</p><ul><li>IGMP：Internet Group Management Protocol</li><li>MLD(Multicast Listener Discovery)：多播监听发现。</li><li>MSS：最大段长度</li><li>链路本地单播地址：同一链路内唯一的地址。</li><li>AS(Autonomous System)：自治系统</li></ul><hr><p>本文为原创文章，包含脚本行为，会经常更新知识点以及修正一些错误，因此转载请保留原出处，方便溯源，避免陈旧错误知识的误导，同时有更好的阅读体验。<br>本文地址：<a href="http://nibnait.com/b3dcfa99-Computer-Networking-advanced/" target="_blank" rel="noopener">http://nibnait.com/b3dcfa99-Computer-Networking-advanced/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目录：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;网络层&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IP多播&lt;/li&gt;
&lt;li&gt;IP隧道 &lt;/li&gt;
&lt;li&gt;IPv6的地址结构&lt;/li&gt;
&lt;li&gt;路径MTU发现&lt;/li&gt;
&lt;li&gt;ICMP报文消息类型详解&lt;/li&gt;
&lt;li&gt;ICMPv6的邻居探索&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://tianbin.org/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="网络" scheme="https://tianbin.org/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络 - 基础</title>
    <link href="https://tianbin.org/reading/58316970-computer_networking_basis/"/>
    <id>https://tianbin.org/reading/58316970-computer_networking_basis/</id>
    <published>2019-06-29T18:48:16.000Z</published>
    <updated>2019-07-15T18:10:28.946Z</updated>
    
    <content type="html"><![CDATA[<p>书单列表：</p><ul><li><a href="https://book.douban.com/subject/24737674/" target="_blank" rel="noopener">《图解TCP/IP(第5版)》</a></li><li><a href="https://book.douban.com/subject/26176870/" target="_blank" rel="noopener">《计算机网络：自顶向下方法(原书第6版)》</a></li></ul><a id="more"></a><p>目录：</p><ol><li>数据链路层  <ul><li>共享介质型网络</li><li>非共享介质型网络</li><li>以太网<ul><li>VLAN</li><li>PPP协议</li></ul></li></ul></li><li><p>网络层</p><ul><li>IPv4编址</li><li>NAT技术</li><li>IPv6与IPv4数据报格式对比</li><li>IP报文的分片与重组</li><li>IP协议相关技术<ul><li>ARP</li><li>RARP</li><li>ICMP</li><li>ICMPv6</li><li>DHCP</li></ul></li><li>路由选择算法<ul><li>距离向量算法 - RIP、RIP2</li><li>链路状态算法 - OSPF</li><li>BGP - 路径向量型协议</li></ul></li></ul></li><li><p>传输层</p><ul><li>UDP - 用户数据报协议</li><li>TCP - 传输控制协议</li><li>其他传输层协议</li></ul></li><li><p>应用层</p><ul><li>远程登录 — TELNET、SSH</li><li>文件传输 — FTP</li><li>电子邮件 — MIME、SMTP、POP、IMAP</li><li>WWW — HTTP</li><li>网络管理 — SNMP、MIB、RMON</li></ul></li></ol><h2 id="TCP-IP的诞生："><a href="#TCP-IP的诞生：" class="headerlink" title="TCP/IP的诞生："></a>TCP/IP的诞生：</h2><p><img src="http://tb.nsfocus.co/image/58316970-1.png" alt="《图解TCP/IP》 P53 表2.1"></p><p>20世纪90年代，ISO展开了OSI这一国际标准协议的标准化进程。然而，OSI协议并没有得到普及，真正被广泛使用的是TCP/IP协议。究其原因，是因为<a href="http://nibnait.com/c09ed94b-TCP-IP-standardization-process/" target="_blank" rel="noopener">TCP/IP的标准化过程</a>是一个极其<strong>注重实用性</strong>的一个流程。</p><h2 id="TCP-IP与OSI参考模型"><a href="#TCP-IP与OSI参考模型" class="headerlink" title="TCP/IP与OSI参考模型"></a>TCP/IP与OSI参考模型</h2><p><img src="http://tb.nsfocus.co/image/58316970-2.png" alt="《图解TCP/IP》 P64 图2.8"></p><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>在LAN内，校验并转发 数据帧(根据MAC地址▼)</p><h2 id="共享介质型网络"><a href="#共享介质型网络" class="headerlink" title="共享介质型网络"></a>共享介质型网络</h2><blockquote><p>   多个设备共享同一个载波信道进行发送和接收数据帧，半双工通信▼。</p></blockquote><ul><li><p>争用方式：CSMA/CD▼</p><ul><li>发前先听</li><li>边发边听</li><li>冲突即停</li><li>延时重发（指数退避等待）</li></ul></li><li><p>令牌传递方式：</p><p>  提高网络性能的两种方法：令牌释放(不等待接收方的数据到达确认就将令牌发送给下一站)、令牌追加(多个令牌同时循环)</p></li></ul><h2 id="非共享介质型网络"><a href="#非共享介质型网络" class="headerlink" title="非共享介质型网络"></a>非共享介质型网络</h2><blockquote><p>   不共享介质。网络中的每个站直连交换机，由交换机负责转发数据帧。由于发送端和接收端并不共享通信介质，所以这种通信方式是全双工的。</p></blockquote><ul><li><p>以太网交换机(网桥)：<strong>转发表</strong>自学原理：</p><ul><li>学习源地址</li><li>转发同网帧</li><li>丢弃异网帧</li><li>广播未知帧</li></ul></li><li><p>环路检测技术：</p><ul><li>生成树协议(STP▼)：通过检查网络的结构 以某一个网桥为构造<strong>树根</strong>，并对每个端口配置<strong>权重</strong>，来指定优先使用哪些端口以及发生问题时该使用哪些端口。</li></ul></li></ul><h2 id="以太网——有线局域网技术"><a href="#以太网——有线局域网技术" class="headerlink" title="以太网——有线局域网技术"></a>以太网——有线局域网技术</h2><p>历史：共享介质型网络—&gt;非共享介质型网络</p><ul><li>以太网帧格式：</li></ul><p><img src="http://tb.nsfocus.co/image/58316970-3.png" alt="Ethernet V2"></p><ul><li>VLAN(virtual LAN，虚拟局域网)</li></ul><blockquote><p>在链路层交换机(网桥)上，使用软件将一些端口逻辑地划分成的一个个网段。</p></blockquote><ul><li>可以跨越不同子网、不同类型网络(以太网、FDDI▼、ATM▼等)从而<strong>简化网络管理，减少设备投资</strong>。</li><li>交换机根据VLAN ID， 可以过滤多余的包，从而达到<strong>控制流量 减少了网络负载</strong> 并 <strong>提高了网络的安全性</strong>。 </li></ul><h2 id="PPP-Point-to-Point-Protocol"><a href="#PPP-Point-to-Point-Protocol" class="headerlink" title="PPP(Point-to-Point Protocol):"></a>PPP(Point-to-Point Protocol):</h2><blockquote><p>   拨号上网时，一个将IP数据报<strong>封装</strong>到串行链路的<strong>方法</strong>。</p></blockquote><p><img src="http://tb.nsfocus.co/image/58316970-4.png" alt="Ethernet V2"></p><p>主要功能：</p><pre><code> -  LCP(链路控制协议)：负责建立、(加密拨号登陆)配置和测试数据链路连接 -  NCP(网络控制协议)：负责设置IP地址(IPCP)、连接上一层</code></pre><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="IP协议：尽力而为-面向无连接的"><a href="#IP协议：尽力而为-面向无连接的" class="headerlink" title="IP协议：尽力而为(面向无连接的)"></a>IP协议：尽力而为(面向无连接的)</h2><p><img src="http://tb.nsfocus.co/image/58316970-5.png" alt="IPv4地址的定义"></p><p>一些特殊的IP地址：</p><div class="table-container"><table><thead><tr><th style="text-align:center">网络号</th><th style="text-align:center">主机号</th><th>10进制表示</th><th style="text-align:center">源地址</th><th style="text-align:center">目的地址</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td>0.0.0.0</td><td style="text-align:center">✔️</td><td style="text-align:center">❌</td><td>本网络上的本主机</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">host-id</td><td></td><td style="text-align:center">✔️</td><td style="text-align:center">❌</td><td>本网络上的某台host-id任播</td></tr><tr><td style="text-align:center">全1</td><td style="text-align:center">全1</td><td>255.255.255.255</td><td style="text-align:center">❌</td><td style="text-align:center">✔️</td><td>本网络上的广播,不能被路由器转发</td></tr><tr><td style="text-align:center">net-id</td><td style="text-align:center">全1</td><td></td><td style="text-align:center">❌</td><td style="text-align:center">✔️</td><td>指定net-id上的所有主机广播</td></tr><tr><td style="text-align:center">127</td><td style="text-align:center">任何数<br>(但不能都是0或1)</td><td>127.×××.×××.×××<br>（默认：127.0.0.1=localhost）</td><td style="text-align:center">✔️</td><td style="text-align:center">✔️</td><td>本地回环测试地址</td></tr></tbody></table></div><h2 id="NAT▼技术：极大的缓解了IPv4地址不够用的囧境"><a href="#NAT▼技术：极大的缓解了IPv4地址不够用的囧境" class="headerlink" title="NAT▼技术：极大的缓解了IPv4地址不够用的囧境"></a>NAT▼技术：极大的缓解了IPv4地址不够用的囧境</h2><blockquote><p>在本地网络中使用私有地址，在连接互联网时转而使用全局IP地址的技术。</p></blockquote><p><img src="http://tb.nsfocus.co/image/58316970-6.png" alt></p><ul><li><p>潜在问题：①无法从NAT外部向内部服务器建立连接；②转换表的生成与转换操作都会产生一定的开销。</p></li><li><p>解决地址短缺的最佳途径还是：普及IPv6。</p></li></ul><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><p><img src="http://tb.nsfocus.co/image/58316970-7.png" alt></p><p>附：<a href="http://tb.nsfocus.co/image/58316970-ipv4-ipv6.png" target="_blank" rel="noopener">IPv4与IPv6数据报格式详解.png</a></p><h2 id="IP报文的分片与重组"><a href="#IP报文的分片与重组" class="headerlink" title="IP报文的分片与重组"></a>IP报文的分片与重组</h2><blockquote><ul><li>IPv4:在路由器上分片，在接收端主机上重组。</li><li>IPv6:在发送端主机上分配，接收端主机重组。最小的MTU==1280字节</li></ul></blockquote><ol><li>通过“路径MTU发现▼”，以确定分片时最大的MTU的大小。<ul><li>主要利用一个ICMP不可达消息 将数据链路上MTU的值返回给发送机</li></ul></li></ol><h2 id="ARP▼"><a href="#ARP▼" class="headerlink" title="ARP▼"></a>ARP▼</h2><blockquote><p>   发送端主机根据IP地址，广播寻找其对应的MAC地址，（只适用于IPv4，IPv6中则可以用ICMPv6替代ARP发送邻居探索消息）实现链路内的IP通信。</p></blockquote><p><img src="http://tb.nsfocus.co/image/58316970-8.png" alt="ARP工作机制"></p><p>附：<a href="http://tb.nsfocus.co/image/58316970-9.png" target="_blank" rel="noopener">ARP包格式.png</a></p><ul><li>ARP缓存表<br> 通常发送端和接受端会把自己接收到的 带有IP地址和MAC地址的ARP响应包/ARP请求包中的信息缓存20分钟。以防止ARP包在网络中被大量广播，造成网络拥塞。</li><li>tips：虽然IP地址直到到达目标主机时都没有发生变化，但是数据链路的目标地址(MAC地址)却根据每个链路的不同而发生着变化。</li><li>MAC地址和IP地址缺一不可<ul><li>在以太网上发送IP包时，“下次要经过哪个路由器发送数据报”中的“下一个路由器”就是其相应的MAC地址。</li><li>而如果没有IP地址，各个主机通信全靠广播MAC地址，那对于网桥来说将是一场灾难。</li></ul></li></ul><h2 id="RARP"><a href="#RARP" class="headerlink" title="RARP"></a>RARP</h2><blockquote><p>   将ARP反过来，从MAC地址定位IP地址。用于将打印机服务器等小型嵌入式设备接入到网络时。</p></blockquote><p><img src="http://tb.nsfocus.co/image/58316970-10.png" alt="RARP工作机制"></p><h2 id="辅助IP的ICMP▼"><a href="#辅助IP的ICMP▼" class="headerlink" title="辅助IP的ICMP▼"></a>辅助IP的ICMP▼</h2><blockquote><p>   用于IP通信过程中，确认网络是否正常工作，以及遇到异常时进行问题的诊断。</p></blockquote><p><img src="http://tb.nsfocus.co/image/58316970-11.png" alt></p><p><img src="http://tb.nsfocus.co/image/58316970-12.png" alt></p><p>附：<a href="http://tianbin.leanote.com/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%9B%E9%98%B6" target="_blank" rel="noopener">《计算机网络-进阶》—ICMP报文消息类型详解</a></p><h2 id="ICMPv6"><a href="#ICMPv6" class="headerlink" title="ICMPv6"></a>ICMPv6</h2><p><img src="http://tb.nsfocus.co/image/58316970-13.png" alt></p><p>附：<a href="http://tianbin.leanote.com/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%9B%E9%98%B6" target="_blank" rel="noopener">《计算机网络-进阶》—ICMPv6的邻居探索</a></p><h2 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h2><ul><li><p>在使用DHCP之前，需先将DHCP所要分配的IP地址池、相应的子网掩码，默认路由控制信息，DNS服务器地址设置到服务器上。</p><p> <img src="http://tb.nsfocus.co/image/58316970-14.png" alt="DHCP的工作原理"></p></li><li><p>DHCP中继代理</p><p> 使用DHCP中继代理之后，对不同网段的IP地址的分配也可以由一个DHCP服务器统一进行管理和维护。</p><p> <img src="http://tb.nsfocus.co/image/58316970-15.png" alt></p></li></ul><h2 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h2><h3 id="距离向量算法-Distance-Vector"><a href="#距离向量算法-Distance-Vector" class="headerlink" title="距离向量算法(Distance-Vector)"></a>距离向量算法(Distance-Vector)</h3><blockquote><p>   根据网络中的距离(跳数)和方向两种信息生成路由控制表。</p></blockquote><ul><li><p>RIP▼</p><ul><li>选择经过路由器个数最少的路径</li><li>每隔30秒与其他相邻的路由器交换自己的路由表</li><li>直接相连的网络距离为0。距离的最大值为16，防止发生“无限计数”问题。</li><li>缺点：<ul><li>网络的个数越多，每次所要交换的路由控制信息就越大。</li><li>在网络比较稳定时，还要定期交换信息，浪费贷款。</li><li>由于每个路由器掌握的信息都不同，其正确性很难保证。</li><li>无法实现可变长度子网构造的网络路由控制（路由器未交换子网掩码）。</li></ul></li></ul></li><li><p>RIP2<br> 与RIP第一版的工作机制基本相同，增加了一些新的特点：<br> <img src="http://tb.nsfocus.co/image/58316970-16.png" alt>        </p></li></ul><h3 id="链路状态算法-Link-State"><a href="#链路状态算法-Link-State" class="headerlink" title="链路状态算法(Link-State)"></a>链路状态算法(Link-State)</h3><blockquote><p>   在了解网络整个链接状态的基础上，所有路由器都持有相同的路由控制表。</p></blockquote><ul><li><p>OSPF▼</p><ul><li>选择总的代价较小的路径。</li><li>允许多条费用相同的路径(而RIP仅一条路径)</li><li>对每条链路，对不同的TOS(服务类型)，设置多种费用测度</li><li><p>在大规模网络中，用层次的OSPF</p><p>附：<a href="http://tb.nsfocus.co/image/58316970-18.png" target="_blank" rel="noopener">OSPF的工作机制.png</a></p></li><li><p>层次OSPF<br><img src="http://tb.nsfocus.co/image/58316970-17.png" alt></p></li></ul></li></ul><h3 id="BGP▼-路径向量型协议"><a href="#BGP▼-路径向量型协议" class="headerlink" title="BGP▼ - 路径向量型协议"></a>BGP▼ - 路径向量型协议</h3><blockquote><p>   边界网关协议是连接不同组织机构(不同自治系统)的一种协议。主要用于ISP之间的相互连接。</p></blockquote><ul><li>根据所要经过的<strong>AS路径信息访问列表</strong>▼进行路由控制。</li><li>AS路径信息访问列表(AS Path List)：包含转发方向、距离以及途径所有AS的编号。</li></ul><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><blockquote><p>   网络层的IP协议相当于邮递员，把IP数据包送到指定IP的目标主机上，<br>   传输层的TCP/UDP则负责 根据包裹信息（应用程序、端口号），判断信息的最终接收人（哪一个应用程序）。</p></blockquote><h2 id="UDP——用户数据报协议"><a href="#UDP——用户数据报协议" class="headerlink" title="UDP——用户数据报协议"></a>UDP——用户数据报协议</h2><blockquote><p>  不提供复杂的控制机制，利用IP提供面向无连接的通信服务。并且它是将应用程序发来的数据在收到的那一刻，立刻按照原样发送到网上的一种机制。 </p></blockquote><p>即使出现网络拥堵，UDP也无法进行流量控制等避免网络拥堵的行为。此外，传输途中即使出现丢包，UDP也不负责重发。甚至当出现包的到达顺序乱掉时也没有纠正的功能。如果需要这些细节控制，那么不得不交由采用UDP的应用程序去处理。UDP有点类似于用户说什么听什么的机制，但是需要用户充分考虑好上层协议类型并制作相应的应用程序。因此，也可以说，UDP按照“制作程序的那些用户的指示行事”。</p><p>由于UDP面向无连接，它可以随时发送数据。再加上UDP本身处理既简单又高效，因此经常用于以下几个方面：</p><ul><li>包总量少的通信（DNS、SNMP等）</li><li>视频、音频等多媒体通信（即时通信）</li><li>限定于LAN等特定网络中的应用通信</li><li>广播通信（广播、多播）</li></ul><p>首部格式：  </p><p><img src="http://tb.nsfocus.co/image/58316970-19.png" alt="UDP数据报格式"></p><p>附：<a href="http://tb.nsfocus.co/image/58316970-UDP.png" target="_blank" rel="noopener">UDP数据报首部“校验和”字段详解.png</a></p><h2 id="TCP——传输控制协议"><a href="#TCP——传输控制协议" class="headerlink" title="TCP——传输控制协议"></a>TCP——传输控制协议</h2><p>目的：通过IP数据报实现可靠性传输</p><p>特点：</p><ul><li>丢包时的<strong>重发控制</strong></li><li>对次序乱掉的分包进行<strong>顺序控制</strong></li><li><strong>面向有连接的协议</strong>，只有在确认对端存在时才会发送数据，从而可以<strong>控制通信流量</strong>的浪费</li><li>使用序列号和确认应答号实现顺序控制、窗口控制与重发控制。</li><li>使用窗口大小来实现对TCP的<strong>流</strong>量大小的<strong>控制</strong> 和 <strong>拥塞控制</strong></li></ul><p>首部格式：  </p><p><img src="http://tb.nsfocus.co/image/58316970-20.png" alt="TCP数据报格式"></p><p>附：<a href="http://tb.nsfocus.co/image/58316970-TCP.png" target="_blank" rel="noopener">TCP数据报首部格式各字段详解.png</a></p><h3 id="TCP连接的建立与终止："><a href="#TCP连接的建立与终止：" class="headerlink" title="TCP连接的建立与终止："></a>TCP连接的建立与终止：</h3><p>(传说中的三次握手与四次挥手)  </p><p><img src="http://tb.nsfocus.co/image/58316970-21.png" alt></p><ol><li>在数据通信之前，主机A通过TCP首部发送一个SYN包作为建立连接的请求（ACK=0,SYN=1，声明一个起始序号seq=x）等待确认应答</li><li>主机B收到A要建立连接的请求，返回一个允许连接的SYNACK报文段（ACK=1,SYN=1，主机B的起始序号seq=y，确认应答号ack=x+1）</li><li>为防止“已失效的连接请求报文段▼”突然又传回B，主机A再进行一次确认（ACK=1,SYN=0，主机A的起始序列号seq=x+1，确认应答号ack=y+1）</li><li>数据传输结束之后，主机A可以发送一个TCP首部（FIN=1，主机A的起始序列号seq=u），请求断开连接。</li><li>主机B收到“A不再发送数据的消息”后，返回一个确认报文（ACK=1,seq=v，ack=u+1）<br>A收到B的确认后，进入等待状态，等待B请求释放连接。</li><li>B数据发送完成之后，向A请求断开连接（FIN=1,ACK=1,seq=w，ack=u+1）  </li><li><p>A收到B的断开请求后，回复一个确认信息，并进入TIME_WAIT状态▼，等待2MSL时间。</p><ul><li>虽然三次握手方式管理TCP连接可以更好地避免无连接，但这种协议为DOS攻击▼（更确切的说是SYN洪泛攻击▼）提供了可乘之机。</li></ul></li></ol><h3 id="使用序列号和确认应答号实现顺序控制、窗口控制与重发控制"><a href="#使用序列号和确认应答号实现顺序控制、窗口控制与重发控制" class="headerlink" title="使用序列号和确认应答号实现顺序控制、窗口控制与重发控制"></a>使用序列号和确认应答号实现顺序控制、窗口控制与重发控制</h3><p><img src="http://tb.nsfocus.co/image/58316970-23.png" alt="确认应答未能返回"></p><p><img src="http://tb.nsfocus.co/image/58316970-24.png" alt="数据报文未能送达"></p><h2 id="其他传输层协议"><a href="#其他传输层协议" class="headerlink" title="其他传输层协议"></a>其他传输层协议</h2><ul><li>UDP-Lite（Lightweight User Datagram Protocol，轻量级用户数据报协议）</li><li>SCTP（Stream Control Transmission Protocol，流控制传输协议）</li><li>DCCP（Datagram Congestion Control Protocol，数据报拥塞控制协议）</li></ul><p>附：<a href="http://tb.nsfocus.co/image/58316970-25.png" target="_blank" rel="noopener">已经步入实用阶段的几个传输层协议详解.png</a></p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>。。。写不动了</p><p>附：<a href="http://tb.nsfocus.co/ppt/58316970-%E8%AE%A1%E7%AE%97%E9%A2%98.pptx" target="_blank" rel="noopener">几道常考的计算题.pptx</a></p><hr><p>本文中提到的一些专有名词：</p><ul><li>MAC地址(Media Access Control Address)：介质访问控制地址。系统在网络上的唯一硬件编号，每个网卡都需要有一个唯一的MAC地址。</li><li>CSMA/CD(Carrier Sense Mutiple Access/Collision Detection)：具有碰撞检测的载波侦听多路访问</li><li>半双工：只发送或只接受的通信方式。比如：无线电收发器，若两端同时说话，是听不见对方说的话的。</li><li>全双工：发送数据的同时也可以接收数据。比如：打电话。</li><li>STP：Spanning Tree Protocol</li><li>SFD：Start Frame Delimiter</li><li>FDDI(Fiber Distribute Data Interface)：<a href="http://baike.baidu.com/view/876931.htm" target="_blank" rel="noopener">分布式光纤数据接口。</a></li><li>ATM(Asynchronous Transfer Mode)：一种以信元为单位的异步传输模式。</li><li>网络收敛：网络拥堵时，路由器或交换机发生丢包的现象。</li><li>PPPoE(PPP over Ethernet)：利用PPP的验证功能使各家ISP▼有效地管理终端用户的使用，实现按时计费。</li><li>ISP:Internet Service Provider </li><li>NAT：Network Address Translator</li><li>Path MTU Discovery：发现路径中存在的所有数据链路中最小的MTU▼</li><li>MTU：Maximum Transmission Unit。参见<a href="http://tianbin.leanote.com/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%9B%E9%98%B6" target="_blank" rel="noopener">《计算机网络-进阶》—路径MTU发现</a></li><li>ARP(Address Resolution Protocol)：地址解析协议</li><li>RARP：Reverse Address Resolution Protocol</li><li>ICMP：Internet Control Managemet Protocol</li><li>DHCP：Dynamic Host Configuration Protocol </li><li>RIP：Routing Information Protocol</li><li>OSPF：Open Shortest Path First</li><li>BGP(Border Gateway Protocol)：边界网关协议</li><li>已失效的连接请求报文段：<br> <img src="http://tb.nsfocus.co/image/58316970-22.png" alt="已失效的连接请求报文段"></li><li>DOS攻击：deny of service</li><li>SYN洪泛攻击:攻击者发送大量的TCP SYN报文段，而有意不进行第三次握手的步骤，直至服务器消耗完为第一次握手连接保留的有限资源。</li><li>TIME_WAIT状态： 在TIME_WAIT状态中，如果TCP client端最后一次发送的ACK丢失了，它将重新发送。TIME_WAIT状态中所需要的时间是依赖于实现方法的。典型的值为30秒、1分钟和2分钟。等待之后连接正式关闭，并且所有的资源(包括端口号)都被释放。</li><li>2MSL(Maximum Segment Lifetime,最大报文生存时间)：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假想网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;书单列表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/24737674/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《图解TCP/IP(第5版)》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/26176870/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《计算机网络：自顶向下方法(原书第6版)》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://tianbin.org/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="网络" scheme="https://tianbin.org/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>我的MBP</title>
    <link href="https://tianbin.org/tool/my_mbp/"/>
    <id>https://tianbin.org/tool/my_mbp/</id>
    <published>2019-06-29T16:59:46.000Z</published>
    <updated>2019-07-15T18:10:28.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="必备工具"><a href="#必备工具" class="headerlink" title="必备工具"></a>必备工具</h1><h2 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a><a href="https://www.google.com/chrome/" target="_blank" rel="noopener">Chrome</a></h2><h2 id="iTerm2-Homebrew-zsh"><a href="#iTerm2-Homebrew-zsh" class="headerlink" title="iTerm2 + Homebrew + zsh"></a><a href="https://www.jianshu.com/p/e7af448d01b0" target="_blank" rel="noopener">iTerm2</a> + <a href="https://www.jianshu.com/p/2b4f00a8e4da" target="_blank" rel="noopener">Homebrew</a> + zsh</h2><a id="more"></a><h2 id="Alfred"><a href="#Alfred" class="headerlink" title="Alfred"></a>Alfred</h2><ul><li>有道 workflow</li><li>剪切板<br>[支持正版，自行购买下载]</li></ul><h2 id="万年历"><a href="#万年历" class="headerlink" title="万年历"></a>万年历</h2><p>App Store免费下载</p><h2 id="CleanMyMac"><a href="#CleanMyMac" class="headerlink" title="CleanMyMac"></a>CleanMyMac</h2><p>彻底卸载App[支持正版，自行购买下载]</p><h1 id="效率工具"><a href="#效率工具" class="headerlink" title="效率工具"></a>效率工具</h1><h2 id="Manico"><a href="#Manico" class="headerlink" title="Manico"></a>Manico</h2><p>App切换<br>App Store免费下载，建议将IntelliJ IDEA加入静默模式</p><h2 id="SktechBook"><a href="#SktechBook" class="headerlink" title="SktechBook"></a>SktechBook</h2><p>画图工具，比Windows里的画图强大100倍。<br>App Store免费下载。</p><h2 id="Spectacle"><a href="#Spectacle" class="headerlink" title="Spectacle"></a><a href="https://www.spectacleapp.com/" target="_blank" rel="noopener">Spectacle</a></h2><p>小眼镜 分屏工具</p><h2 id="Sublime-Text-3"><a href="#Sublime-Text-3" class="headerlink" title="Sublime Text 3"></a><a href="https://www.sublimetext.com/" target="_blank" rel="noopener">Sublime Text 3</a></h2><p>ctrl + `</p><p>获取package control最新安装代码：<a href="https://packagecontrol.io/installation" target="_blank" rel="noopener">https://packagecontrol.io/installation</a></p><p>cmd+shift+p<br>package control: install package<br>cmd+shift+p<br>pretty json</p><h3 id="Preferences-—-gt-Key-Bindings："><a href="#Preferences-—-gt-Key-Bindings：" class="headerlink" title="Preferences —&gt; Key Bindings："></a>Preferences —&gt; Key Bindings：</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123; <span class="attr">"keys"</span>: [<span class="string">"super+i"</span>], <span class="attr">"command"</span>: <span class="string">"copy_path"</span> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="typora"><a href="#typora" class="headerlink" title="typora"></a><a href="https://typora.io/" target="_blank" rel="noopener">typora</a></h2><p>轻量级Markdown编辑神器！</p><h1 id="专业工具"><a href="#专业工具" class="headerlink" title="专业工具"></a>专业工具</h1><h2 id="Parallels-Desktop"><a href="#Parallels-Desktop" class="headerlink" title="Parallels Desktop"></a>Parallels Desktop</h2><p>虚拟机</p><h2 id="Java开发环境"><a href="#Java开发环境" class="headerlink" title="Java开发环境"></a><a href="https://cloud.tencent.com/developer/article/1113909" target="_blank" rel="noopener">Java开发环境</a></h2><h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><ul><li>JDK 1.8：<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></li><li>JDK 1.7：<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html</a></li><li>JDK 1.6：<a href="http://www.oracle.com/technetwork/java/javase/downloads/java-archive-downloads-javase6-419409.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/java-archive-downloads-javase6-419409.html</a></li><li>JDK 1.5：<a href="http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-javase5-419410.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-javase5-419410.html</a></li></ul><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a><a href="https://www.jianshu.com/p/96021a36e000" target="_blank" rel="noopener">Maven</a></h2><h2 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h2><p><a href="https://www.jetbrains.com/idea/download/#section=mac" target="_blank" rel="noopener">download</a><br><a href="http://idea.lanyus.com/" target="_blank" rel="noopener">lanyus</a></p><p>算法测试Code Templates:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#if ($&#123;PACKAGE_NAME&#125; &amp;&amp; $&#123;PACKAGE_NAME&#125; != "")package $&#123;PACKAGE_NAME&#125;;#end</span><br><span class="line">#parse("File Header.java")</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> junit.framework.TestCase;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> $</span>&#123;NAME&#125; extends TestCase &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Xmind"><a href="#Xmind" class="headerlink" title="Xmind"></a>Xmind</h2><h2 id="Visual-Paradigm"><a href="#Visual-Paradigm" class="headerlink" title="Visual Paradigm"></a>Visual Paradigm</h2><h2 id="文本比较工具"><a href="#文本比较工具" class="headerlink" title="文本比较工具"></a>文本比较工具</h2><ul><li><a href="https://sourcegear.com/diffmerge/downloads.php" target="_blank" rel="noopener">DiffMerge</a> 轻量级，容易更改系统文件打开方式</li><li><a href="https://www.scootersoftware.com/download.php" target="_blank" rel="noopener">Beyond Compare</a> 重、总崩、需破解</li></ul><h2 id="Charles"><a href="#Charles" class="headerlink" title="Charles"></a><a href="https://www.charlesproxy.com/download/" target="_blank" rel="noopener">Charles</a></h2><h3 id="安装证书"><a href="#安装证书" class="headerlink" title="安装证书"></a>安装证书</h3><h4 id="PC端"><a href="#PC端" class="headerlink" title="PC端"></a>PC端</h4><p> “Help” -&gt; “SSL Proxying” -&gt; “Install Charles Root Certificate”</p><h4 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h4><p>“Help” -&gt; “SSL Proxying” -&gt; “Install Charles Root Certificate on a Mobile Device or Remote Browser”</p><ol><li><p>访问chls.pro/ssl自动<strong>下载</strong>证书。（此时要确认已经将WiFi的代理模式改为“手动”模式，服务器和端口号填写正确）</p><p>如果还是没有自动下载，也可以点击这个链接 `<a href="https://www.charlesproxy.com/assets/legacy-ssl/charles.crt直接下载（参考文档：[Legacy" target="_blank" rel="noopener">https://www.charlesproxy.com/assets/legacy-ssl/charles.crt直接下载（参考文档：[Legacy</a> SSL Proxying](<a href="https://www.charlesproxy.com/documentation/additional/legacy-ssl-proxying/" target="_blank" rel="noopener">https://www.charlesproxy.com/documentation/additional/legacy-ssl-proxying/</a>) ）</p></li><li><p>设置-&gt;通用-&gt;描述文件与设备管理中<strong>安装</strong>。</p></li><li><p>设置-&gt;通用-&gt;关于本机-&gt;证书信任设置，<strong>开启信任</strong>Charles Proxy SSL Proxying</p></li></ol><p>安卓手机也可能不能从服务器下载证书，可以在pc端的 Charles 从 “Help” -&gt; “SSL Proxying” -&gt; “Save Charles Root Certificate”导出后，在手机 设置&gt;安全&gt;安装证书 本地安装。</p><h3 id="Https设置白名单"><a href="#Https设置白名单" class="headerlink" title="Https设置白名单"></a>Https设置白名单</h3><p>“Proxy”-&gt;”SSL Proxying Settings”，添加 <code>*:*</code></p><p>安装chrome的插件<a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif" target="_blank" rel="noopener">Proxy SwitchyOmega</a>，切换到127.0.0.1:8888的代理，即可使用Charles抓本地浏览器的包了。</p><p>另一种方法：<a href="https://www.charlesproxy.com/documentation/using-charles/ssl-certificates/" target="_blank" rel="noopener">https://www.charlesproxy.com/documentation/using-charles/ssl-certificates/</a></p><p><strong>注：由于现在的app都有SSL证书检测机制，用 charles 进行 https 的抓包本质上就是作为一个中间人代理用自己生成的 SSL 证书来完成 https 请求的过程，这样就导致客户端接收到的 SSL 证书其实是一个假的，所以客户端不认这个证书，导致unknown，</strong>解决方案：使用一些手段（ROOT / 越狱），是你的要抓的app信任你的Charles证书，或者安装app的debug包。</p><h1 id="APP-Store精选"><a href="#APP-Store精选" class="headerlink" title="APP Store精选"></a>APP Store精选</h1><p>偶然发现的一些免费小玩意：</p><ul><li>Maipo for 微博</li><li>魔力拼图Lite</li><li>五子棋 Gomoku</li><li>扫雷 Minesweeper Deluxe</li></ul><h1 id="装X工具"><a href="#装X工具" class="headerlink" title="装X工具"></a>装X工具</h1><h2 id="Aerial"><a href="#Aerial" class="headerlink" title="Aerial"></a>Aerial</h2><p>桌面屏保</p><h2 id="iStat-Menus"><a href="#iStat-Menus" class="headerlink" title="iStat Menus"></a>iStat Menus</h2><p>[支持正版，自行购买下载]</p><h2 id="uBar"><a href="#uBar" class="headerlink" title="uBar"></a>uBar</h2><p>win风格的任务栏<br>[支持正版，自行购买下载]</p><h2 id="Commander-One"><a href="#Commander-One" class="headerlink" title="Commander One"></a>Commander One</h2><p>文件管理<br>[支持正版，自行购买下载]</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;必备工具&quot;&gt;&lt;a href=&quot;#必备工具&quot; class=&quot;headerlink&quot; title=&quot;必备工具&quot;&gt;&lt;/a&gt;必备工具&lt;/h1&gt;&lt;h2 id=&quot;Chrome&quot;&gt;&lt;a href=&quot;#Chrome&quot; class=&quot;headerlink&quot; title=&quot;Chrome&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.google.com/chrome/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Chrome&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;iTerm2-Homebrew-zsh&quot;&gt;&lt;a href=&quot;#iTerm2-Homebrew-zsh&quot; class=&quot;headerlink&quot; title=&quot;iTerm2 + Homebrew + zsh&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.jianshu.com/p/e7af448d01b0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;iTerm2&lt;/a&gt; + &lt;a href=&quot;https://www.jianshu.com/p/2b4f00a8e4da&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Homebrew&lt;/a&gt; + zsh&lt;/h2&gt;
    
    </summary>
    
      <category term="工具" scheme="https://tianbin.org/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Mac" scheme="https://tianbin.org/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Linux 常用命令</title>
    <link href="https://tianbin.org/tool/linux_command/"/>
    <id>https://tianbin.org/tool/linux_command/</id>
    <published>2019-06-29T16:54:54.000Z</published>
    <updated>2019-07-15T18:10:28.949Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查看大文件"><a href="#查看大文件" class="headerlink" title="查看大文件"></a>查看大文件</h1><p>进入根目录，查看那个目录的利用率(used)达到了100%</p><blockquote><p>df -lh #查看磁盘空间占用情况<br>（<a href="https://www.cnblogs.com/peida/archive/2012/12/07/2806483.html" target="_blank" rel="noopener">每天一个linux命令（33）：df 命令</a>）</p></blockquote><a id="more"></a><p>进入log目录，</p><blockquote><p>du -h #显示当前目录下的文件的磁盘空间使用情况<br>相当于 ls -aslh<br>（<a href="https://www.cnblogs.com/peida/archive/2012/12/10/2810755.html" target="_blank" rel="noopener">每天一个linux命令（34）：du 命令</a>）</p></blockquote><h1 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h1><p><a href="https://www.cnblogs.com/peida/archive/2012/12/17/2821195.html" target="_blank" rel="noopener">https://www.cnblogs.com/peida/archive/2012/12/17/2821195.html</a></p><blockquote></blockquote><h1 id="less"><a href="#less" class="headerlink" title="less"></a>less</h1><p><a href="https://www.cnblogs.com/peida/archive/2012/11/05/2754477.html" target="_blank" rel="noopener">每天一个linux命令（13）：less 命令</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;查看大文件&quot;&gt;&lt;a href=&quot;#查看大文件&quot; class=&quot;headerlink&quot; title=&quot;查看大文件&quot;&gt;&lt;/a&gt;查看大文件&lt;/h1&gt;&lt;p&gt;进入根目录，查看那个目录的利用率(used)达到了100%&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;df -lh #查看磁盘空间占用情况&lt;br&gt;（&lt;a href=&quot;https://www.cnblogs.com/peida/archive/2012/12/07/2806483.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;每天一个linux命令（33）：df 命令&lt;/a&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="工具" scheme="https://tianbin.org/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Linux" scheme="https://tianbin.org/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Git 小技巧</title>
    <link href="https://tianbin.org/tool/git_skills/"/>
    <id>https://tianbin.org/tool/git_skills/</id>
    <published>2019-06-29T16:51:02.000Z</published>
    <updated>2019-07-15T18:28:24.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="启用大小写敏感"><a href="#启用大小写敏感" class="headerlink" title="启用大小写敏感"></a>启用大小写敏感</h1><blockquote><p>git config —global core.ignorecase false （- - global）</p></blockquote><h1 id="批量删除分支"><a href="#批量删除分支" class="headerlink" title="批量删除分支"></a>批量删除分支</h1><pre><code>git branch | grep &#39;hotfix&#39; | xargs git branch -D</code></pre><a id="more"></a><h1 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h1><p>合并多个commit 为1个commit，然后确保本地的git log为最新的时，即可直接<code>git push origin &lt;branch&gt; -f</code></p><h2 id="查看git提交日志："><a href="#查看git提交日志：" class="headerlink" title="查看git提交日志："></a>查看git提交日志：</h2><blockquote><p>git log —graph —pretty=oneline —abbrev-commit</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* a5da1fb (HEAD -&gt; master, origin/master) 第4次commit</span><br><span class="line">* 0c20956 第3次commit</span><br><span class="line">* 230096e 第2次commit</span><br><span class="line">* 7bfab4e 第1次commit</span><br></pre></td></tr></table></figure><h2 id="git-rebase-1"><a href="#git-rebase-1" class="headerlink" title="git rebase"></a>git rebase</h2><p>想要合并1-3条，有两个方法：</p><ol><li>从HEAD版本开始往过去数3个版本</li></ol><blockquote><p>git rebase -i HEAD~3</p></blockquote><ol><li>指名要合并的版本之前的版本号</li></ol><blockquote><p>git rebase -i 7bfab4e</p></blockquote><p>请注意7bfab4e这个版本是不参与合并的，可以把它当做一个坐标</p><h2 id="选取要合并的提交"><a href="#选取要合并的提交" class="headerlink" title="选取要合并的提交"></a>选取要合并的提交</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pick 230096e 第2次commit</span><br><span class="line">pick 0c20956 第3次commit</span><br><span class="line">pick a5da1fb 第4次commit</span><br><span class="line"></span><br><span class="line">将下面两个pick 手动改成 s或squash</span><br><span class="line">pick 230096e 第2次commit</span><br><span class="line">s 0c20956 第3次commit</span><br><span class="line">s a5da1fb 第4次commit</span><br></pre></td></tr></table></figure><p>保存并退出<code>:wq</code>，然后会弹出一条<code>&quot;This is a combination of 3 commits&quot;</code>的提示，继续保存并退出<code>:wq</code></p><blockquote><p>git add .（如果有冲突，合并冲突后，执行此命令）</p><p>git rebase —continue（continue前面是两个 - - ）</p><p>【放弃本次rebase是：git rebase —abort（abort前面是两个 - -）】</p></blockquote><h2 id="修改合并后的commit信息"><a href="#修改合并后的commit信息" class="headerlink" title="修改合并后的commit信息"></a>修改合并后的commit信息</h2><blockquote><p>git commit —amend</p></blockquote><h2 id="push-f-到远程"><a href="#push-f-到远程" class="headerlink" title="push -f 到远程"></a>push -f 到远程</h2><p>确保本地的git log是最新的</p><blockquote><p>git push origin <code>&lt;branch&gt;</code> -f</p></blockquote><h1 id="统计代码行数"><a href="#统计代码行数" class="headerlink" title="统计代码行数"></a>统计代码行数</h1><pre><code>git log --author=&quot;username&quot; --pretty=tformat: --numstat | awk &#39;{ add += $1; subs += $2; loc += $1 - $2 } END { printf &quot;added lines: %s, removed lines: %s, total lines: %s\n&quot;, add, subs, loc }&#39;git log --author=&quot;nibnait&quot; --pretty=tformat: --numstat | awk &#39;{ add += $1; subs += $2; loc += $1 - $2 } END { printf &quot;added lines: %s, removed lines: %s, total lines: %s\n&quot;, add, subs, loc }&#39;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;启用大小写敏感&quot;&gt;&lt;a href=&quot;#启用大小写敏感&quot; class=&quot;headerlink&quot; title=&quot;启用大小写敏感&quot;&gt;&lt;/a&gt;启用大小写敏感&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;git config —global core.ignorecase false （- - global）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;批量删除分支&quot;&gt;&lt;a href=&quot;#批量删除分支&quot; class=&quot;headerlink&quot; title=&quot;批量删除分支&quot;&gt;&lt;/a&gt;批量删除分支&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;git branch | grep &amp;#39;hotfix&amp;#39; | xargs git branch -D
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="工具" scheme="https://tianbin.org/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Git" scheme="https://tianbin.org/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Mac 小技巧</title>
    <link href="https://tianbin.org/tool/mac_skills/"/>
    <id>https://tianbin.org/tool/mac_skills/</id>
    <published>2019-06-29T16:21:33.000Z</published>
    <updated>2019-07-15T18:10:28.949Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解压-rar、-7z文件"><a href="#解压-rar、-7z文件" class="headerlink" title="解压.rar、.7z文件"></a>解压.rar、.7z文件</h1><blockquote><p>unrar x 1.rar<br>7z e 1.7z</p></blockquote><a id="more"></a><h2 id="before"><a href="#before" class="headerlink" title="before:"></a>before:</h2><blockquote><p>brew install unrar</p><p>brew search 7z<br>brew install p7zip </p></blockquote><h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><p><code>Updating Homebrew...</code></p><ul><li>法1：</li></ul><p>替换brew.git:<br>cd “$(brew —repo)”<br>git remote set-url origin <a href="https://mirrors.ustc.edu.cn/brew.git" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/brew.git</a></p><p>替换homebrew-core.git:<br>cd “$(brew —repo)/Library/Taps/homebrew/homebrew-core”<br>git remote set-url origin <a href="https://mirrors.ustc.edu.cn/homebrew-core.git" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/homebrew-core.git</a> </p><ul><li>法2: </li></ul><p>重置brew.git:<br>cd “$(brew —repo)”<br>git remote set-url origin <a href="https://github.com/Homebrew/brew.git" target="_blank" rel="noopener">https://github.com/Homebrew/brew.git</a></p><p>重置homebrew-core.git:<br>cd “$(brew —repo)/Library/Taps/homebrew/homebrew-core”<br>git remote set-url origin <a href="https://github.com/Homebrew/homebrew-core.git" target="_blank" rel="noopener">https://github.com/Homebrew/homebrew-core.git</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;解压-rar、-7z文件&quot;&gt;&lt;a href=&quot;#解压-rar、-7z文件&quot; class=&quot;headerlink&quot; title=&quot;解压.rar、.7z文件&quot;&gt;&lt;/a&gt;解压.rar、.7z文件&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;unrar x 1.rar&lt;br&gt;7z e 1.7z&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="工具" scheme="https://tianbin.org/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Mac" scheme="https://tianbin.org/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 启用 cdn 加速</title>
    <link href="https://tianbin.org/trying/83f2d349-cdn/"/>
    <id>https://tianbin.org/trying/83f2d349-cdn/</id>
    <published>2019-06-29T07:06:00.000Z</published>
    <updated>2019-07-15T18:10:28.950Z</updated>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://shup.cn/2017/11/21/cdn.html" target="_blank" rel="noopener">https://shup.cn/2017/11/21/cdn.html</a></p><a id="more"></a><h1 id="分析：哪些因素会影响加载速度？"><a href="#分析：哪些因素会影响加载速度？" class="headerlink" title="分析：哪些因素会影响加载速度？"></a>分析：哪些因素会影响加载速度？</h1><h2 id="js文件"><a href="#js文件" class="headerlink" title="js文件"></a>js文件</h2><p>js文件就是JavaScript脚本文件，用来实现各种酷炫的动态效果。一般是加载在html页面的<head><meta name="generator" content="Hexo 3.9.0">部分，所以页面加载速度首先要考虑这一块。Hexo的js文件大致包含以下3类：</head></p><ol><li>公共js<br>公共js是通用型，比如实现图片放大效果的Fancybox，或者实现图片慢加载的LazyLoad等等。这些js已经开发好，直接在html里引用(存放在镜像网站上，如<a href="https://www.bootcdn.cn/" target="_blank" rel="noopener">BootCDN</a>)js文件链接即可实现效果。</li><li>定制页面效果js<br>即NexT主题中定制的某些特效，例如实现页面响应式效果的Bootstrap，或者增强移动端滚动及动画效果的Motion等等。这些js理论上也是公共js，只不过NexT主题作者修改了代码，以适用于NexT主题。这些js文件存放在本地Hexo目录hexo\themes\next\source\js\src下。</li><li>第三方插件js<br>这个不用多说了吧，Hexo默认安装了不少实用的第三方插件，比如，可直接在网页中显示数学公式的MathJax，优化SEO的Baidu-push等等。这些插件可在主题配置文件_config.yml中进行配置。相关js文件有些存放在hexo\themes\next\layout_third-party中，有些则通过外部引用形式加载。<h2 id="图片-音、视频"><a href="#图片-音、视频" class="headerlink" title="图片(音、视频)"></a>图片(音、视频)</h2>如果博客文章很多，绝大部分的带宽都会消耗在这部分静态数据上。这个不多说了。</li></ol><h1 id="解决：逐个优化"><a href="#解决：逐个优化" class="headerlink" title="解决：逐个优化"></a>解决：逐个优化</h1><h2 id="公共js加速"><a href="#公共js加速" class="headerlink" title="公共js加速"></a>公共js加速</h2><p>修改<a href="../../themes/next/_config.yml">_config.yml</a>中 vendors 的配置<br>全部映射到BootCDN上去</p><h2 id="第三方js文件、图片-音、视频-加速"><a href="#第三方js文件、图片-音、视频-加速" class="headerlink" title="第三方js文件、图片(音、视频)加速"></a>第三方js文件、图片(音、视频)加速</h2><p>我用的七牛云，<a href="https://blog.qiniu.com/archives/8874" target="_blank" rel="noopener">每月 10 G的标准存储 CDN 回源流量免费额度</a><a href="https://blog.qiniu.com/archives/8874)。" target="_blank" rel="noopener">https://blog.qiniu.com/archives/8874)。</a><br><img src="http://tb.nsfocus.co/image/83f2d349-1.png" alt="七牛云"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;a href=&quot;https://shup.cn/2017/11/21/cdn.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://shup.cn/2017/11/21/cdn.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="搞点事情" scheme="https://tianbin.org/categories/%E6%90%9E%E7%82%B9%E4%BA%8B%E6%83%85/"/>
    
    
      <category term="网络" scheme="https://tianbin.org/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="hexo" scheme="https://tianbin.org/tags/hexo/"/>
    
      <category term="cdn" scheme="https://tianbin.org/tags/cdn/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 启用 https 加密连接</title>
    <link href="https://tianbin.org/trying/https/"/>
    <id>https://tianbin.org/trying/https/</id>
    <published>2019-06-29T06:06:00.000Z</published>
    <updated>2019-07-15T18:10:28.951Z</updated>
    
    <content type="html"><![CDATA[<p><a href="(https://www.cloudflare.com/">CloudFlare</a>) 提供免费的SSL证书和cdn加速服务。目前还在研究中。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;(https://www.cloudflare.com/&quot;&gt;CloudFlare&lt;/a&gt;) 提供免费的SSL证书和cdn加速服务。目前还在研究中。&lt;/p&gt;
    
    </summary>
    
      <category term="搞点事情" scheme="https://tianbin.org/categories/%E6%90%9E%E7%82%B9%E4%BA%8B%E6%83%85/"/>
    
    
      <category term="网络" scheme="https://tianbin.org/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="hexo" scheme="https://tianbin.org/tags/hexo/"/>
    
      <category term="https" scheme="https://tianbin.org/tags/https/"/>
    
  </entry>
  
</feed>
